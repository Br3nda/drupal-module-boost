<?php
// $Id: boost.module,v 1.3.2.2.2.5.2.6 2008/10/25 01:55:50 arto Exp $

/**
 * @file
 * Provides static page caching for Drupal.
 */

//////////////////////////////////////////////////////////////////////////////
// Module settings

define('BOOST_PATH',                 dirname(__FILE__));
define('BOOST_ENABLED',              variable_get('boost', CACHE_DISABLED));
define('BOOST_FILE_PATH',            variable_get('boost_file_path', 'cache'));
define('BOOST_FILE_EXTENSION',       variable_get('boost_file_extension', '.html'));
define('BOOST_MAX_PATH_DEPTH',       10);
define('BOOST_CACHEABILITY_OPTION',  variable_get('boost_cacheability_option', 0));
define('BOOST_CACHEABILITY_PAGES',   variable_get('boost_cacheability_pages', ''));
define('BOOST_FETCH_METHOD',         variable_get('boost_fetch_method', 'php'));
define('BOOST_PRE_PROCESS_FUNCTION', variable_get('boost_pre_process_function', ''));
define('BOOST_POST_UPDATE_COMMAND',  variable_get('boost_post_update_command', ''));
define('BOOST_CRON_LIMIT',           variable_get('boost_cron_limit', 100));

// This cookie is set for all logged-in users, so that they can be excluded
// from caching (or, in the future, get a user-specific cached page):
define('BOOST_COOKIE',               variable_get('boost_cookie', 'DRUPAL_UID'));

// This line is appended to the generated static files; it is very useful
// for troubleshooting (e.g. determining whether one got the dynamic or
// static version):
define('BOOST_BANNER',               variable_get('boost_banner', "<!-- Page cached by Boost at %cached_at, expires at %expires_at -->\n"));

// This is needed since the $user object is already destructed in _boost_ob_handler():
define('BOOST_USER_ID',              $GLOBALS['user']->uid);

//////////////////////////////////////////////////////////////////////////////
// Core API hooks

/**
 * Implementation of hook_help(). Provides online user help.
 */
function boost_help($path, $arg) {
  switch ($path) {
    case 'admin/help#boost':
      if (file_exists($file = drupal_get_path('module', 'boost') . '/README.txt')) {
        return '<pre>' . implode("\n", array_slice(explode("\n", @file_get_contents($file)), 2)) . '</pre>';
      }
      break;
    case 'admin/settings/performance/boost':
      return '<p>' . t('') . '</p>'; // TODO: add help text.
  }
}

/**
 * Implementation of hook_init(). Performs page setup tasks if page not cached.
 */
function boost_init() {
  // Stop right here unless we're being called for an ordinary page request
  if (strpos($_SERVER['PHP_SELF'], 'index.php') === FALSE)
    return;

  // This is defined here now instead of at the beginning of the file, as D6
  // loads path.inc after parsing this file looking for hook_boot():
  define('BOOST_FRONTPAGE', drupal_get_normal_path(variable_get('site_frontpage', 'node')));

  // TODO: check interaction with other modules that use ob_start(); this
  // may have to be moved to an earlier stage of the page request.
  if (!variable_get('cache', CACHE_DISABLED) && BOOST_ENABLED) {
    // We only support GET requests by anonymous visitors:
    global $user;
    if (empty($user->uid) && $_SERVER['REQUEST_METHOD'] == 'GET') {
      // Make sure no query string (in addition to ?q=) was set, and that
      // the page is cacheable according to our current configuration:
      if (count($_GET) == 1 && boost_is_cacheable($_GET['q'])) {
        // In the event of errors such as drupal_not_found(), GET['q'] is
        // changed before _boost_ob_handler() is called. Apache is going to
        // look in the cache for the original path, however, so we need to
        // preserve it.
        $GLOBALS['_boost_path'] = $_GET['q'];
        ob_start('_boost_ob_handler');
      }
    }
  }
}

/**
 * Implementation of hook_exit(). Performs cleanup tasks.
 *
 * For POST requests by anonymous visitors, this adds a dummy query string
 * to any URL being redirected to using drupal_goto().
 *
 * This is pretty much a hack that assumes a bit too much familiarity with
 * what happens under the hood of the Drupal core function drupal_goto().
 *
 * It's necessary, though, in order for any session messages set on form
 * submission to actually show up on the next page if that page has been
 * cached by Boost.
 */
function boost_exit($destination = NULL) {
  // Check that hook_exit() was invoked by drupal_goto() for a POST request:
  if (!empty($destination) && $_SERVER['REQUEST_METHOD'] == 'POST') {

    // Check that we're dealing with an anonymous visitor. and that some
    // session messages have actually been set during this page request:
    global $user;
    if (empty($user->uid) && ($messages = drupal_set_message())) {

      // Check that the page we're redirecting to really necessitates
      // special handling, i.e. it doesn't have a query string:
      extract(parse_url($destination));
      $path = ($path == base_path() ? '' : substr($path, strlen(base_path())));
      if (empty($query)) {
        // FIXME: call any remaining exit hooks since we're about to terminate?

        // If no query string was previously set, add one just to ensure we
        // don't serve a static copy of the page we're redirecting to, which
        // would prevent the session messages from showing up:
        $destination = url($path, 't=' . time(), $fragment, TRUE);

        // Do what drupal_goto() would do if we were to return to it:
        exit(header('Location: ' . $destination));
      }
    }
  }
}

/**
 * Implementation of hook_form_alter(). Performs alterations before a form
 * is rendered.
 */
function boost_form_alter(&$form, $form_state, $form_id) {
  // Alter Drupal's settings form by hiding the default cache
  // enabled/disabled control (which will now always default to
  // CACHE_DISABLED), and add our own control instead.
  if ($form_id == 'system_performance_settings') {
    module_load_include('inc', 'boost', 'boost.admin');
    $form['page_cache'] = boost_admin_settings($form['page_cache']);
    $form['#validate'][] = 'boost_admin_settings_validate';
    $form['#submit'][] = 'boost_admin_settings_submit';
    $form['clear_cache']['clear']['#submit'][0] = 'boost_admin_clear_cache_submit';
  }
}

/**
 * Implementation of hook_cron(). Performs periodic actions.
 */
function boost_cron() {
  if (!BOOST_ENABLED) return;

  if (boost_cache_expire_all()) {
    watchdog('boost', 'Expired stale files from static page cache.', array(), WATCHDOG_NOTICE);
  }
}

/**
 * Implementation of hook_comment(). Acts on comment modification.
 */
function boost_comment($comment, $op) {
  if (!BOOST_ENABLED) return;

  switch ($op) {
    case 'insert':
    case 'update':
      // Expire the relevant node page from the static page cache to prevent serving stale content:
      if (!empty($comment['nid'])) {
        boost_cache_expire('node/' . $comment['nid'], TRUE);
      }
      break;
  }
}

/**
 * Implementation of hook_nodeapi(). Acts on nodes defined by other modules.
 */
function boost_nodeapi(&$node, $op, $teaser = NULL, $page = NULL) {
  if (!BOOST_ENABLED) return;

  switch ($op) {
    case 'insert':
    case 'update':
    case 'delete':
      // Expire all relevant node pages from the static page cache to prevent serving stale content:
      if (!empty($node->nid)) {
        boost_cache_expire('node/' . $node->nid, TRUE);
      }
      break;
  }
}

/**
 * Implementation of hook_taxonomy(). Acts on taxonomy changes.
 */
function boost_taxonomy($op, $type, $term = NULL) {
  if (!BOOST_ENABLED) return;

  switch ($op) {
    case 'insert':
    case 'update':
    case 'delete':
      // TODO: Expire all relevant taxonomy pages from the static page cache to prevent serving stale content.
      break;
  }
}

/**
 * Implementation of hook_user(). Acts on user account actions.
 */
function boost_user($op, &$edit, &$account, $category = NULL) {
  if (!BOOST_ENABLED) return;

  global $user;
  switch ($op) {
    case 'login':
      // Set special cookie to prevent logged-in users getting served pages from the static page cache.
      $expires = ini_get('session.cookie_lifetime');
      $expires = (!empty($expires) && is_numeric($expires) ? time() + (int)$expires : 0);
      setcookie(BOOST_COOKIE, $user->uid, $expires, ini_get('session.cookie_path'), ini_get('session.cookie_domain'), ini_get('session.cookie_secure') == '1');
      break;
    case 'logout':
      setcookie(BOOST_COOKIE, FALSE, time() - 86400, ini_get('session.cookie_path'), ini_get('session.cookie_domain'), ini_get('session.cookie_secure') == '1');
      break;
    case 'insert':
      // TODO: create user-specific cache directory.
      break;
    case 'delete':
      // Expire the relevant user page from the static page cache to prevent serving stale content:
      if (!empty($account->uid)) {
        boost_cache_expire('user/' . $account->uid);
      }
      // TODO: recursively delete user-specific cache directory.
      break;
  }
}

//////////////////////////////////////////////////////////////////////////////
// Output buffering callback

/**
 * PHP output buffering callback for static page caching.
 *
 * NOTE: objects have already been destructed so $user is not available.
 */
function _boost_ob_handler($buffer) {
  // Ensure we're in the correct working directory, since some web servers (e.g. Apache) mess this up here.
  chdir(dirname($_SERVER['SCRIPT_FILENAME']));

  // Check the currently set content type; at present we can't deal with anything else than HTML.
  if (_boost_get_content_type() == 'text/html') {
    if (strlen($buffer) > 0) { // Sanity check
      boost_cache_set($GLOBALS['_boost_path'], $buffer);
    }
  }

  // Allow the page request to finish up normally
  return $buffer;
}

/**
 * Determines the MIME content type of the current page response based on
 * the currently set Content-Type HTTP header.
 *
 * This should normally return the string 'text/html' unless another module
 * has overridden the content type.
 */
function _boost_get_content_type($default = NULL) {
  static $regex = '/^Content-Type:\s*([\w\d\/\-]+)/i';

  // The last Content-Type header is the one that counts:
  $headers = preg_grep($regex, explode("\n", drupal_set_header()));
  if (!empty($headers) && preg_match($regex, array_pop($headers), $matches)) {
    return $matches[1]; // found it
  }

  return $default;
}

//////////////////////////////////////////////////////////////////////////////
// Boost API implementation

/**
 * Determines whether a given Drupal page can be cached or not.
 *
 * To avoid potentially troublesome situations, the user login page is never
 * cached, nor are any admin pages. At present, we also refuse to cache any
 * RSS feeds provided by Drupal, since they would require special handling
 * in the mod_rewrite ruleset as they shouldn't be sent out using the
 * text/html content type.
 */
function boost_is_cacheable($path) {
  $alias = drupal_get_path_alias($path);
  $path = drupal_get_normal_path($path); // normalize path

  // Never cache the basic user login/registration pages or any administration pages
  if ($path == 'user' || preg_match('!^user/(login|register|password)!', $path) || preg_match('!^admin!', $path))
    return FALSE;

  // At present, RSS feeds are not cacheable due to content type restrictions
  if ($path == 'rss.xml' || preg_match('!/feed$!', $path))
    return FALSE;

  // Don't cache comment reply pages
  if (preg_match('!^comment/reply!', $path))
    return FALSE;

  // Match the user's cacheability settings against the path
  if (BOOST_CACHEABILITY_OPTION == 2) {
    $result = drupal_eval(BOOST_CACHEABILITY_PAGES);
    return !empty($result);
  }
  $regexp = '/^('. preg_replace(array('/(\r\n?|\n)/', '/\\\\\*/', '/(^|\|)\\\\<front\\\\>($|\|)/'), array('|', '.*', '\1'. preg_quote(variable_get('site_frontpage', 'node'), '/') .'\2'), preg_quote(BOOST_CACHEABILITY_PAGES, '/')) .')$/';
  return !(BOOST_CACHEABILITY_OPTION xor preg_match($regexp, $alias));
}

/**
 * Determines whether a given Drupal page is currently cached or not.
 */
function boost_is_cached($path) {
  $path = (empty($path) ? BOOST_FRONTPAGE : $path);
  $alias = drupal_get_path_alias($path);
  $path = drupal_get_normal_path($path); // normalize path

  // TODO: also determine if alias/symlink exists?
  return file_exists(boost_file_path($path));
}

/**
 * Deletes all static files currently in the cache.
 */
function boost_cache_clear_all() {
  clearstatcache();
  if (($cache_dir = boost_cache_directory()) && file_exists($cache_dir)) {
    return _boost_rmdir_rf($cache_dir);
  }
}

/**
 * Deletes all expired static files currently in the cache.
 */
function boost_cache_expire_all() {
  clearstatcache();
  if (($cache_dir = boost_cache_directory()) && file_exists($cache_dir)) {
    _boost_rmdir_rf($cache_dir, 'boost_file_is_expired');
  }
  return TRUE;
}

/**
 * Expires the static file cache for a given page, or multiple pages
 * matching a wildcard.
 */
function boost_cache_expire($path, $wildcard = FALSE) {
  // TODO: handle wildcard.

  $alias = drupal_get_path_alias($path);
  $path = drupal_get_normal_path($path); // normalize path

  if (($filename = boost_file_path($path)) && file_exists($filename)) {
    @unlink($filename);
  }

  if ($alias != $path && ($symlink = boost_file_path($alias)) && is_link($symlink)) {
    @unlink($symlink);
  }

  return TRUE;
}

/**
 * Returns the cached contents of the specified page, if available.
 */
function boost_cache_get($path) {
  $path = drupal_get_normal_path($path); // normalize path

  if (($filename = boost_file_path($path))) {
    if (file_exists($filename) && is_readable($filename)) {
      return file_get_contents($filename);
    }
  }

  return NULL;
}


/**
 * Replaces the cached contents of the specified page, if stale.
 */
function boost_cache_set($path, $data = '') {
  // Append the Boost footer with the relevant timestamps
  $time = time();
  $cached_at = date('Y-m-d H:i:s', $time);
  $expires_at = date('Y-m-d H:i:s', $time + variable_get('cache_lifetime', 600));
  $data = rtrim($data) . "\n" . str_replace(array('%cached_at', '%expires_at'), array($cached_at, $expires_at), BOOST_BANNER);

  // Execute the pre-process function if one has been defined
  if (function_exists(BOOST_PRE_PROCESS_FUNCTION))
    $data = call_user_func(BOOST_PRE_PROCESS_FUNCTION, $data);

  $alias = drupal_get_path_alias($path);
  $path = drupal_get_normal_path($path); // normalize path

  // Create or update the static file as needed
  if (($filename = boost_file_path($path))) {
    _boost_mkdir_p(dirname($filename));
    if (!file_exists($filename) || boost_file_is_expired($filename)) {
      if (file_put_contents($filename, $data) === FALSE) {
        watchdog('boost', 'Unable to write file: %file', array('%file' => $filename), array(), WATCHDOG_WARNING);
      }
    }

    // If a URL alias is defined, create that as a symlink to the actual file
    if ($alias != $path && ($symlink = boost_file_path($alias))) {
      _boost_mkdir_p(dirname($symlink));
      if (!is_link($symlink) || realpath(readlink($symlink)) != realpath($filename)) {
        if (file_exists($symlink)) {
          @unlink($symlink);
        }
        if (!_boost_symlink($filename, $symlink)) {
          watchdog('boost', 'Unable to create symlink: %link to %target', array('%link' => $symlink, '%target' => $filename), array(), WATCHDOG_WARNING);
        }
      }
    }
  }

  return TRUE;
}

/**
 * Returns the full directory path to the static file cache directory.
 */
function boost_cache_directory($user_id = 0, $host = NULL) {
  global $user, $base_url;
  $user_id = 0; //(!is_null($user_id) ? $user_id : BOOST_USER_ID);
  $parts = parse_url($base_url);
  $host = (!empty($host) ? $host : $parts['host']);

  // FIXME: correctly handle Drupal subdirectory installations.
  return implode('/', array(getcwd(), BOOST_FILE_PATH, $host, $user_id));
}

/**
 * Returns the static file path for a Drupal page.
 */
function boost_file_path($path) {
  if (empty($path) || $path == BOOST_FRONTPAGE) {
    $path = 'index'; // special handling for Drupal's front page
  }

  // Under no circumstances should the incoming path contain '..' or null
  // bytes; we also limit the maximum directory nesting depth of the path
  if (strpos($path, '..') !== FALSE || strpos($path, "\0") !== FALSE ||
      count(explode('/', $path)) > BOOST_MAX_PATH_DEPTH) {
    return FALSE;
  }

  // Convert any other undesirable characters in the path to underscores:
  $path = preg_replace('@[^/a-z0-9_-]@i', '_', $path);

  return boost_cache_directory() . '/' . $path . BOOST_FILE_EXTENSION;
}

/**
 * Returns the age of a cached file, measured in seconds since it was last
 * updated.
 */
function boost_file_get_age($filename) {
  return time() - filemtime($filename);
}

/**
 * Determines whether a cached file has expired, i.e. whether its age
 * exceeds the maximum cache lifetime as defined by Drupal's system
 * settings.
 */
function boost_file_is_expired($filename) {
  if (is_link($filename))
    return FALSE;
  return boost_file_get_age($filename) > variable_get('cache_lifetime', 600);
}

//////////////////////////////////////////////////////////////////////////////
// Boost API internals

/**
 * Recursive version of mkdir(), compatible with PHP4.
 */
function _boost_mkdir_p($pathname, $mode = 0775, $recursive = TRUE) {
  if (is_dir($pathname)) return TRUE;
  if ($recursive && !_boost_mkdir_p(dirname($pathname), $mode)) return FALSE;
  if ($result = @mkdir($pathname, $mode))
    @chmod($pathname, $mode);
  return $result;
}

/**
 * Recursive version of rmdir(); use with extreme caution.
 *
 * @param $dirname
 *   the top-level directory that will be recursively removed
 * @param $callback
 *   optional predicate function for determining if a file should be removed
 */
function _boost_rmdir_rf($dirname, $callback = NULL) {
  $empty = TRUE; // Start with an optimistic mindset

  foreach (glob($dirname . '/*', GLOB_NOSORT) as $file) {
    if (is_dir($file)) {
      if (!_boost_rmdir_rf($file, $callback))
        $empty = FALSE;
    }
    else if (is_file($file)) {
      if (function_exists($callback)) {
        if (!$callback($file)) {
          $empty = FALSE;
          continue;
        }
      }
      @unlink($file);
    }
    else {
      $empty = FALSE; // it's probably a symbolic link
    }
  }

  // The reason for this elaborate safeguard is that Drupal will log even
  // warnings that should have been suppressed with the @ sign. Otherwise,
  // we'd just rely on the FALSE return value from rmdir().
  return ($empty && @rmdir($dirname));
}

/**
 * Creates a symbolic link using a computed relative path where possible.
 */
function _boost_symlink($target, $link) {
  if (!file_exists($target) || !file_exists(dirname($link)))
    return FALSE;

  $target = explode('/', $target);
  $link = explode('/', $link);

  // Only bother creating a relative link if the paths are in the same
  // top-level directory; otherwise just symlink to the absolute path.
  if ($target[1] == $link[1]) {
    // Remove the common path prefix
    $cwd = array();
    while (count($target) > 0 && count($link) > 0 && reset($target) == reset($link)) {
      $cwd[] = array_shift($target);
      array_shift($link);
    }
    // Compute the required relative path
    if (count($link) > 1)
      $target = array_merge(array_fill(0, count($link) - 1, '..'), $target);
    $link = array_merge($cwd, $link);
  }

  return symlink(implode('/', $target), implode('/', $link));
}

//////////////////////////////////////////////////////////////////////////////
// PHP 4.x compatibility

if (!function_exists('file_put_contents')) {
  function file_put_contents($filename, $data) {
    if ($fp = fopen($filename, 'wb')) {
      fwrite($fp, $data);
      fclose($fp);
      return filesize($filename);
    }
    return FALSE;
  }
}
