<?php
// $Id: boost.module,v 1.3.2.2.2.5.2.129 2009/09/04 06:56:59 mikeytown2 Exp $

/**
 * @file
 * Provides static file caching for Drupal text output. Pages, Feeds, ect...
 */

//////////////////////////////////////////////////////////////////////////////
// Module settings

define('BOOST_PATH',                 dirname(__FILE__));
define('BOOST_ENABLED',              variable_get('boost_enabled', CACHE_DISABLED));
define('BOOST_MULTISITE_SINGLE_DB',  variable_get('boost_multisite_single_db', FALSE));
define('BOOST_ROOT_CACHE_DIR',       variable_get('boost_root_cache_dir', 'cache'));
define('BOOST_NORMAL_DIR',           variable_get('boost_normal_dir', ''));
define('BOOST_GZIP_DIR',             variable_get('boost_gzip_dir', 'gz'));
define('BOOST_PERM_NORMAL_DIR',      variable_get('boost_perm_normal_dir', ''));
define('BOOST_PERM_GZ_DIR',          variable_get('boost_perm_gz_dir', 'gz'));
define('BOOST_CHAR',                 variable_get('boost_char', '_'));
define('BOOST_PERM_CHAR',            variable_get('boost_perm_char', '_'));
define('BOOST_HOST',                 variable_get('boost_host', ''));
define('BOOST_FILE_PATH',            BOOST_MULTISITE_SINGLE_DB ? boost_cache_directory(NULL, FALSE) : variable_get('boost_file_path', boost_cache_directory(BOOST_HOST, FALSE)));
define('BOOST_GZIP_FILE_PATH',       implode('/', array_filter(explode('/', str_replace(BOOST_ROOT_CACHE_DIR . '/' . BOOST_NORMAL_DIR, BOOST_ROOT_CACHE_DIR . '/' . BOOST_GZIP_DIR . '/', BOOST_FILE_PATH)))));
define('BOOST_PERM_GZIP_FILE_PATH',  implode('/', array_filter(explode('/', str_replace(BOOST_ROOT_CACHE_DIR . '/' . BOOST_NORMAL_DIR, BOOST_ROOT_CACHE_DIR . '/' . BOOST_PERM_GZ_DIR . '/', BOOST_FILE_PATH)))));
define('BOOST_PERM_FILE_PATH',       implode('/', array_filter(explode('/', str_replace(BOOST_ROOT_CACHE_DIR . '/' . BOOST_NORMAL_DIR, BOOST_ROOT_CACHE_DIR . '/' . BOOST_PERM_NORMAL_DIR . '/', BOOST_FILE_PATH)))));
define('BOOST_FILE_EXTENSION',       variable_get('boost_file_extension', '.html'));
define('BOOST_XML_EXTENSION',        variable_get('boost_xml_extension', '.xml'));
define('BOOST_JSON_EXTENSION',       variable_get('boost_json_extension', '.js'));
define('BOOST_CSS_EXTENSION',        variable_get('boost_css_extension', '.css'));
define('BOOST_JS_EXTENSION',         variable_get('boost_js_extension', '.js'));
define('BOOST_GZIP_EXTENSION',       variable_get('boost_gzip_extension', '.gz'));
define('BOOST_CACHE_XML',            variable_get('boost_cache_xml', FALSE));
define('BOOST_CACHE_JSON',           variable_get('boost_cache_json', FALSE));
define('BOOST_CACHE_HTML',           variable_get('boost_cache_html', TRUE));
define('BOOST_CACHE_CSS',            variable_get('boost_cache_css', TRUE));
define('BOOST_CACHE_JS',             variable_get('boost_cache_js', TRUE));
define('BOOST_PUSH_HTML',            variable_get('boost_push_html', FALSE));
define('BOOST_PUSH_XML',             variable_get('boost_push_xml', FALSE));
define('BOOST_PUSH_JSON',            variable_get('boost_push_json', FALSE));
define('BOOST_CACHE_LIFETIME',       variable_get('boost_cache_lifetime', 3600));
define('BOOST_CACHE_XML_LIFETIME',   variable_get('boost_cache_xml_lifetime', 3600));
define('BOOST_CACHE_JSON_LIFETIME',  variable_get('boost_cache_json_lifetime', 3600));
define('BOOST_MAX_PATH_DEPTH',       10);
define('BOOST_CACHEABILITY_OPTION',  variable_get('boost_cacheability_option', 0));
define('BOOST_CACHEABILITY_PAGES',   variable_get('boost_cacheability_pages', ''));
define('BOOST_FETCH_METHOD',         variable_get('boost_fetch_method', 'php'));
define('BOOST_PRE_PROCESS_FUNCTION', variable_get('boost_pre_process_function', ''));
define('BOOST_POST_UPDATE_COMMAND',  variable_get('boost_post_update_command', ''));
define('BOOST_CRON_LIMIT',           variable_get('boost_cron_limit', 100));
define('BOOST_ONLY_ASCII_PATH',      variable_get('boost_only_ascii_path', TRUE));
define('BOOST_GZIP',                 variable_get('page_compression', TRUE));
define('BOOST_AGGRESSIVE_GZIP',      variable_get('boost_aggressive_gzip', FALSE));
define('BOOST_CLEAR_CACHE_OFFLINE',  variable_get('boost_clear_cache_offline', TRUE));
define('BOOST_HALT_ON_ERRORS',       variable_get('boost_halt_on_errors', FALSE));
define('BOOST_ROOT_FILE',            variable_get('boost_root_file', '.boost'));
define('BOOST_FLUSH_DIR',            variable_get('boost_flush_dir', TRUE));
define('BOOST_TIME',                 time());
define('BOOST_CACHE_QUERY',          variable_get('boost_cache_query', TRUE));
define('BOOST_IGNORE_FLUSH',         variable_get('boost_ignore_flush', 0));
define('BOOST_PERMISSIONS_FILE',     variable_get('boost_permissions_file', ''));
define('BOOST_PERMISSIONS_DIR',      variable_get('boost_permissions_dir', ''));
define('BOOST_OVERWRITE_FILE',       variable_get('boost_overwrite_file', FALSE));
define('BOOST_DISABLE_CLEAN_URL',    variable_get('boost_disable_clean_url', FALSE));
define('BOOST_VERBOSE',              variable_get('boost_verbose', 5));
define('BOOST_FLUSH_NODE_TERMS',     variable_get('boost_flush_node_terms', TRUE));
define('BOOST_CRAWL_ON_CRON',        variable_get('boost_crawl_on_cron', FALSE));
define('BOOST_MAX_TIMESTAMP',        variable_get('boost_max_timestamp', BOOST_TIME));
define('BOOST_CHECK_BEFORE_CRON_EXPIRE', variable_get('boost_check_before_cron_expire', FALSE));
define('BOOST_CRAWLER_THROTTLE',     variable_get('boost_crawler_throttle', 0));
define('BOOST_CRAWLER_THREADS',      variable_get('boost_crawler_threads', 2));
define('BOOST_CRAWLER_BATCH_SIZE',   variable_get('boost_crawler_batch_size', 25));
define('BOOST_CRAWL_URL_ALIAS',      variable_get('boost_crawl_url_alias', FALSE));
global $base_url;
define('BOOST_CRAWLER_SELF',         $base_url . '/' . 'boost-crawler?nocache=1&key=' . variable_get('boost_crawler_key', FALSE));

// This cookie is set for all authenticated users, so that they can be
// excluded from caching (or in the future get a user-specific cached page):
define('BOOST_COOKIE',               variable_get('boost_cookie', 'DRUPAL_UID'));

// This line is appended to the generated static files; it is very useful
// for troubleshooting (e.g. determining whether one got the dynamic or
// static version):
define('BOOST_BANNER',               variable_get('boost_banner', "Page cached by Boost @ %cached_at, expires @ %expires_at"));

// This is needed since the $user object is already destructed in _boost_ob_handler():
define('BOOST_USER_ID',              @$GLOBALS['user']->uid);

//////////////////////////////////////////////////////////////////////////////
// Global variables

//$GLOBALS['_boost_path'] = '';
//$GLOBALS['_boost_query'] = '';
//$GLOBALS['_boost_message_count'] = '';
//$GLOBALS['_boost_cache_this'] = '';

//////////////////////////////////////////////////////////////////////////////
// Core API hooks

/**
 * Implementation of hook_help(). Provides online user help.
 */
function boost_help($path, $arg) {
  switch ($path) {
    case 'admin/help#boost':
      if (file_exists($file = drupal_get_path('module', 'boost') . '/README.txt')) {
        return '<pre>' . implode("\n", array_slice(explode("\n", @file_get_contents($file)), 2)) . '</pre>';
      }
      break;
    case 'admin/settings/performance/boost':
      return '<p>' . t('') . '</p>'; // TODO: add help text.
  }
  //hack to get drupal_get_messages before they are destroyed.
  $GLOBALS['_boost_message_count'] = count(drupal_get_messages(NULL, FALSE));
}

/**
 * Implementation of hook_init(). Performs page setup tasks if page not cached.
 */
function boost_init() {
  global $user, $base_path;
  //set variables
  $GLOBALS['_boost_path'] = $_REQUEST['q'];
  // Make the proper filename for our query
  $GLOBALS['_boost_query'] = BOOST_CHAR;
  foreach ($_GET as $key => $val) {
    if ($key != 'q' && $key != 'destination') {
      $GLOBALS['_boost_query'] .= (($GLOBALS['_boost_query'] == BOOST_CHAR) ? '' : '&') . $key . '=' . $val;
    }
  }

  if (!empty($user->uid)) {
    boost_set_cookie($user);
    if (BOOST_DISABLE_CLEAN_URL) {
      $GLOBALS['conf']['clean_url'] = 0;
      db_query('TRUNCATE {cache_filter}');
      db_query('TRUNCATE {cache_menu}');
      cache_clear_all('*', 'cache_menu');
      cache_clear_all('*', 'cache_filter');
    }
  }

  // Make sure the page is/should be cached according to our current configuration
  if (   strpos($_SERVER['SCRIPT_FILENAME'], 'index.php') === FALSE
      || variable_get('site_offline', 0)
      || $_SERVER['REQUEST_METHOD'] != 'GET'
      || $_SERVER['SERVER_SOFTWARE'] === 'PHP CLI'
      || !BOOST_ENABLED
      || isset($_GET['nocache'])
      || !boost_is_cacheable($GLOBALS['_boost_path'])
      ) {
    $GLOBALS['_boost_cache_this'] = FALSE;
    return;
  }

  // We only generate cached pages for anonymous visitors.
  if (empty($user->uid)) {
    if (BOOST_ENABLED != CACHE_AGGRESSIVE) {
      $GLOBALS['conf']['cache'] = CACHE_DISABLED;
    }
    $GLOBALS['_boost_cache_this'] = TRUE;
    ob_start('_boost_ob_handler');
  }
}

/**
 * Implementation of hook_exit(). Performs cleanup tasks.
 *
 * For POST requests by anonymous visitors, this adds a dummy query string
 * to any URL being redirected to using drupal_goto().
 *
 * This is pretty much a hack that assumes a bit too much familiarity with
 * what happens under the hood of the Drupal core function drupal_goto().
 *
 * It's necessary, though, in order for any session messages set on form
 * submission to actually show up on the next page if that page has been
 * cached by Boost.
 */
function boost_exit($destination = NULL) {
  // Check that hook_exit() was invoked by drupal_goto() for a POST request:
  if (!empty($destination) && $_SERVER['REQUEST_METHOD'] == 'POST') {

    // Check that we're dealing with an anonymous visitor. and that some
    // session messages have actually been set during this page request:
    global $user;
    if (empty($user->uid) && ($messages = drupal_set_message())) {
      // FIXME: call any remaining exit hooks since we're about to terminate?

      $query_parts = parse_url($destination);
      // Add a nocache parameter to query. Such pages will never be cached
      $query_parts['query'] .= (empty($query_parts['query']) ? '' : '&') . 'nocache=1';

      // Rebuild the URL with the new query string.  Do not use url() since
      // destination has presumably already been run through url().
      $destination = boost_glue_url($query_parts);

      // Do what drupal_goto() would do if we were to return to it:
      exit(header('Location: ' . $destination));
    }
  }
}

/**
 * Implementation of hook_menu().
 */
function boost_menu() {
  $items['admin/settings/performance/default'] = array(
    'title' => 'Performance',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'file path' => drupal_get_path('module', 'system'),
  );
  $items['admin/settings/performance/boost'] = array(
    'title' => 'Boost Settings',
    'description' => 'Advanced boost configuration.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('boost_admin_boost_performance_page'),
    'access arguments' => array('administer site configuration'),
    'weight' => 10,
    'type' => MENU_LOCAL_TASK,
    'file' => 'boost.admin.inc',
  );
  $items['boost_stats.php'] = array(
    'page callback' => 'boost_stats_ajax_callback',
    'type' => MENU_CALLBACK,
    'access callback' => 1,
    'access arguments' => array('access content'),
    'file path' => drupal_get_path('module', 'boost'),
    'file' => 'stats/boost_stats.ajax.inc',
  );
  $items['boost-crawler'] = array(
    'page callback' => 'boost_crawler_run',
    'type' => MENU_CALLBACK,
    'access callback' => 1,
    'access arguments' => array('access content'),
    'file path' => drupal_get_path('module', 'boost'),
  );
  return $items;
}

/**
 * Implementation of hook_form_alter(). Performs alterations before a form
 * is rendered.
 */
function boost_form_alter(&$form, $form_state, $form_id) {
  switch ($form_id) {

    // Alter Drupal's system performance settings form by hiding the default
    // cache enabled/disabled control (which will now always default to
    // CACHE_DISABLED), and inject our own settings in its stead.
    case 'system_performance_settings':
      module_load_include('inc', 'boost', 'boost.admin');
      $form['page_cache'] = boost_admin_performance_page($form['page_cache']);
      $form['page_cache']['#title'] = t('Anonymous page caching');
      $form['page_cache']['#description'] = t('Enabling the page cache will offer a significant performance boost. Drupal can store and send compressed cached pages requested by <em>anonymous</em> users. By caching the first request to the page, Drupal does not have to construct the page each time it is viewed. The page must first be visited by an anonymous user in order for the cache to work on subsequent requests for that page. Boost & Core caching do not work for logged in users.');
      $form['#submit'][] = 'boost_admin_performance_page_submit';
      $form['clear_cache']['clear']['#submit'][0] = 'boost_admin_clear_cache_submit';
      break;

    // Alter Drupal's site maintenance settings form in order to ensure that
    // the static page cache gets wiped if the administrator decides to take
    // the site offline.
    case 'system_site_maintenance_settings':
      module_load_include('inc', 'boost', 'boost.admin');
      $form['#submit'][] = 'boost_admin_site_offline_submit';
      break;

    // Alter Drupal's modules build form in order to ensure that
    // the static page cache gets wiped if the administrator decides to
    // change enabled modules
    case 'system_modules':
      module_load_include('inc', 'boost', 'boost.admin');
      $form['#submit'][] = 'boost_admin_modules_submit';
      break;

    // Alter Drupal's theme build form in order to ensure that
    // the static page cache gets wiped if the administrator decides to
    // change theme
    case 'system_themes_form':
      module_load_include('inc', 'boost', 'boost.admin');
      $form['#submit'][] = 'boost_admin_themes_submit';

      // Added below due to this bug: http://drupal.org/node/276615
      if (variable_get('preprocess_css', FALSE)==TRUE) {
        if (boost_cache_clear_all()) {
          drupal_set_message(t('Boost: Static page cache cleared. See <a href="http://drupal.org/node/276615">http://drupal.org/node/276615</a> for reason why (core bug).'), 'warning');
        }
      }
      break;
  }
}

/**
 * Implementation of hook_cron(). Performs periodic actions.
 */
function boost_cron() {
  if (!BOOST_ENABLED) {
    return;
  }

  $expire = TRUE;
  if (BOOST_CHECK_BEFORE_CRON_EXPIRE) {
    $expire = boost_has_site_changed();
  }
  // Expire old content
  if (variable_get('boost_expire_cron', TRUE) && $expire && boost_cache_db_expire()) {
    if (BOOST_VERBOSE >= 5) {
      watchdog('boost', 'Expired stale files from static page cache.', array(), WATCHDOG_NOTICE);
    }
  }

  // Update Stats
  if (module_exists('statistics') && variable_get('boost_block_show_stats', FALSE)) {
    $block = module_invoke('statistics', 'block', 'view', 0);
    variable_set('boost_statistics_html', $block['content']);
  }

  // Crawl Site
  if (BOOST_CRAWL_ON_CRON) {
    boost_crawler_run();
  }
}

/*
 * Implementation of hook_flush_caches(). Deletes all static files.
 */
function boost_flush_caches() {
  if (variable_get('cron_semaphore', FALSE)==FALSE && (variable_get('preprocess_css', FALSE)==TRUE || variable_get('preprocess_js', FALSE)==TRUE)) {
    boost_cache_clear_all();
  }
  return;
}

/**
 * Implementation of hook_comment(). Acts on comment modification.
 */
function boost_comment($comment, $op) {
  if (!BOOST_ENABLED) return;

  switch ($op) {
    case 'insert':
    case 'update':
      // Expire the relevant node page from the static page cache to prevent serving stale content:
      if (!empty($comment['nid'])) {
        boost_cache_expire_derivative('node/' . $comment['nid'], TRUE);
      }
      break;
    case 'publish':
    case 'unpublish':
    case 'delete':
      if (!empty($comment->nid)) {
        boost_cache_expire_derivative('node/' . $comment->nid, TRUE);
      }
      break;
  }
}

/**
 * Implementation of hook_nodeapi(). Acts on nodes defined by other modules.
 */
function boost_nodeapi(&$node, $op, $teaser = NULL, $page = NULL) {
  if (!BOOST_ENABLED) return;

  switch ($op) {
    case 'insert':
    case 'update':
    case 'delete':
      // Expire all relevant node pages from the static page cache to prevent serving stale content:
      if (!empty($node->nid)) {
        if ($node->promote == 1) {
          boost_cache_expire_derivative('<front>');
        }
        boost_cache_expire_derivative('node/' . $node->nid, TRUE);
      }

      // get terms and flush their page
      if (module_exists('taxonomy') && BOOST_FLUSH_NODE_TERMS) {
        $tids = boost_taxonomy_node_get_tids($node->nid);
        $filenames = array();
        foreach($tids as $tid) {
          $filenames = array_merge($filenames, boost_get_db_term($tid));
        }
        foreach($filenames as $filename) {
          boost_cache_kill($filename);
        }
      }
      break;
  }
}

/**
 * Return taxonomy terms given a nid.
 *
 * Needed because of a weird bug with CCK & node_load()
 *  http://drupal.org/node/545922
 */
function boost_taxonomy_node_get_tids($nid) {
  $vid = db_result(db_query('SELECT vid FROM {node} WHERE nid = %d', $nid));
  $result = db_query(db_rewrite_sql('SELECT t.tid FROM {term_node} r INNER JOIN {term_data} t ON r.tid = t.tid INNER JOIN {vocabulary} v ON t.vid = v.vid WHERE r.vid = %d ORDER BY v.weight, t.weight, t.name', 't', 'tid'), $vid);
  $tids = array();
  while ($term = db_result($result)) {
    $tids[] = $term;
  }
  return $tids;
}

/**
 * Implementation of hook_taxonomy(). Acts on taxonomy changes.
 */
function boost_taxonomy($op, $type, $term = NULL) {
  if (!BOOST_ENABLED) return;

  switch ($op) {
    case 'insert':
    case 'update':
    case 'delete':
      // TODO: Expire all relevant taxonomy pages from the static page cache to prevent serving stale content.
      break;
  }
}

/**
 * Implementation of hook_user(). Acts on user account actions.
 */
function boost_user($op, &$edit, &$account, $category = NULL) {
  if (!BOOST_ENABLED) return;

  global $user;
  switch ($op) {
    case 'login':
      // Set a special cookie to prevent authenticated users getting served
      // pages from the static page cache.
      boost_set_cookie($user);
      break;
    case 'logout':
      boost_set_cookie($user, BOOST_TIME - 86400);
      break;
    case 'insert':
      // TODO: create user-specific cache directory.
      break;
    case 'delete':
      // Expire the relevant user page from the static page cache to prevent serving stale content:
      if (!empty($account->uid)) {
        boost_cache_expire_derivative('user/' . $account->uid);
      }
      // TODO: recursively delete user-specific cache directory.
      break;
  }
}

/**
 * Implementation of hook_block().
 */
function boost_block($op = 'list', $delta = 0, $edit = array()) {
  global $user;

  switch ($op) {
    case 'list':
      return array(
        'status' => array(
          'info'   => t('Boost: Pages cache status'),
          'region' => 'right',
          'weight' => 10,
          'cache'  => BLOCK_NO_CACHE,
        ),
        'config' => array(
          'info'   => t('Boost: Pages cache configuration'),
          'region' => 'right',
          'weight' => 10,
          'cache'  => BLOCK_NO_CACHE,
        ),
        'stats' => array(
          'info'   => t('Boost: AJAX core statistics'),
          'region' => 'right',
          'weight' => 10,
          'cache'  => BLOCK_NO_CACHE,
        ),
      );
    case 'configure':
      if ($delta == 'stats') {
        $form['boost_block_show_stats'] = array(
        '#type' => 'checkbox',
        '#title' => t('Display Statistics.'),
        '#default_value' => variable_get('boost_block_show_stats', FALSE),
        '#description' => t('If false, uses Javascript to hide the block via "parent().parent().hide()".'),
        );
        $form['boost_block_cache_stats_block'] = array(
        '#type' => 'checkbox',
        '#title' => t('Cache Statistics Block'),
        '#default_value' => variable_get('boost_block_cache_stats_block', FALSE),
        );
      return $form;
      }
    case 'save':
      if ($delta == 'stats') {
        variable_set('boost_block_show_stats', $edit['boost_block_show_stats']);
        variable_set('boost_block_cache_stats_block', $edit['boost_block_cache_stats_block']);
      }
    case 'view':
      $block = array();
      switch ($delta) {
        case 'status':
          // Don't show the block to anonymous users, nor on any pages that
          // aren't even cacheable to begin with (e.g. admin/*).
          if (!empty($user->uid) && boost_is_cacheable($GLOBALS['_boost_path'])) {
            $output = t('This page is being served <strong>live</strong> to anonymous visitors, as it is not currently in the static page cache.');

            if (boost_is_cached($GLOBALS['_boost_path'])) {
              $ttl = boost_db_get_ttl(boost_file_path($GLOBALS['_boost_path']));
              $output = t('This page is being served to anonymous visitors from the static page cache.') . ' ';
              $output .= t($ttl < 0 ?
                '<strong>The cached copy expired %interval ago.</strong>' :
                'The cached copy will expire in %interval.',
                array('%interval' => format_interval(abs($ttl))));
              $output .=  drupal_get_form('boost_block_flush_form');
            }
            $error = FALSE;
            if (function_exists('error_get_last')) {
              $error = error_get_last();
            }
            $drupal_msg = max(count(drupal_get_messages(NULL, FALSE)), $GLOBALS['_boost_message_count']);

            if (BOOST_HALT_ON_ERRORS && ($error || $drupal_msg != 0)) {
              $output = t('There are <strong>php errors</strong> or <strong>drupal messages</strong> on this page, preventing boost from caching.');
              if ($error) {
                $output .= t(' ERROR: <pre>%error</pre> !link <br /> !performance', array('%error' => boost_print_r($error, TRUE), '!link' => l(t('Lookup Error Type'), 'http://php.net/errorfunc.constants'), '!performance' => l(t('Turn Off Error Checking'), 'admin/settings/performance')));
              }
              if ($drupal_msg != 0) {
                $output .= t(' MESSAGES: %msg <br /> !performance', array('%msg' => $drupal_msg, '!performance' => l(t('Turn Off Error Checking'), 'admin/settings/performance')));
              }
            }

            $block['subject'] = '';
            $block['content'] = theme('boost_cache_status', isset($ttl) ? $ttl : -1, $output);
          }
          break;
        case 'config':
          // Don't show the block to anonymous users, nor on any pages that
          // aren't even cacheable to begin with (e.g. admin/*).
          if (!empty($user->uid) && boost_is_cacheable($GLOBALS['_boost_path'])) {
            $block['subject'] = '';
            $block['content'] = theme('boost_cache_status', -1, drupal_get_form('boost_block_db_settings_form'));
          }
          break;
        case 'stats':
          $filename = 'boost_stats.php';
          $block = module_invoke('statistics', 'block', 'view', 0);
          variable_set('boost_statistics_html', $block['content']);

          if (!( strpos($_SERVER['SCRIPT_FILENAME'], 'index.php') === FALSE
              || variable_get('site_offline', 0)
              || $_SERVER['REQUEST_METHOD'] != 'GET'
              || $_SERVER['SERVER_SOFTWARE'] === 'PHP CLI'
              || !BOOST_ENABLED
              || isset($_GET['nocache'])
              || !boost_is_cacheable($GLOBALS['_boost_path'])
              || !empty($user->uid)
              || !module_exists('statistics')
              )) {
            $block = array();
            $block['subject'] = 'Popular content';
            $block['content'] = '<div id="boost-stats"></div>' . boost_stats_generate($filename);
          }
          elseif (!variable_get('boost_block_show_stats', FALSE)) {
            $block['content'] .= '<div id="boost-stats"></div>';
            drupal_add_js('$("#boost-stats").parent().parent().hide();', 'inline', 'footer');
          }
          break;
      }
      return $block;
  }
}

function boost_block_flush_form() {
  $form['boost_clear']['path'] = array(
    '#type' => 'hidden',
    '#value' => $GLOBALS['_boost_path'],
  );
  $form['boost_cache']['clear'] = array(
    '#type' => 'submit',
    '#value' => t('Flush Page'),
    '#submit' => array('boost_block_form_flush_submit'),
  );
  return ($form);
}

function boost_block_form_flush_submit(&$form_state, $form) {
  boost_cache_expire_derivative($form['values']['path'], TRUE);
}

function boost_block_db_settings_form() {
  // set info
  $period = drupal_map_assoc(array(-1, 0, 60, 180, 300, 600, 900, 1800, 2700, 3600, 10800, 21600, 32400, 43200, 64800, 86400, 2*86400, 3*86400, 4*86400, 5*86400, 6*86400, 604800, 2*604800, 3*604800, 4*604800, 8*604800, 16*604800, 52*604800), 'format_interval');
  $period[0] = '<' . t('none') . '>';
  $period[-1] = t('default');
  //$info = boost_get_db(boost_file_path($GLOBALS['_boost_path']));
  $router_item = _boost_get_menu_router();
  $settings = boost_get_settings_db($router_item);
  $default = 0;
  foreach ($settings as $key => $value) {
    if ($value != NULL) {
      $info = $value;
      $default = $key;
      break;
    }
  }
  if (!isset($info)) {
    $info['lifetime'] = -1;
    $info['push'] = -1;
  }
  // create form
  $form['boost_db_settings']['lifetime'] = array(
    '#type' => 'select',
    '#title' => t('Minimum cache lifetime'),
    '#default_value' => $info['lifetime'],
    '#options' => $period,
    '#description' => t('Default: %default', array('%default' => format_interval(BOOST_CACHE_LIFETIME))),
  );
  $form['boost_db_settings']['push'] = array(
    '#type' => 'select',
    '#title' => t('Preemptive Cache'),
    '#default_value' => $info['push'],
    '#options' => array(
      -1 => 'default',
      0 => 'No',
      1 => 'Yes',
    ),
  );
  $form['boost_db_settings']['selection'] = array(
    '#type' => 'select',
    '#title' => t('Scope'),
    '#default_value' => $default,
    '#options' => array(
      0 => 'Page ID: ' . $router_item['page_id'],
      1 => 'Content Type: ' . $router_item['page_arguments'],
      2 => 'Content Container: ' . $router_item['page_callback'],
    ),
  );
  $form['boost_db_settings']['send'] = array(
    '#type' => 'submit',
    '#value' => t('Set Configuration'),
    '#submit' => array('boost_block_db_settings_form_submit'),
  );

  $form['boost_db_rm_settings']['id'] = array(
    '#type' => 'checkbox',
    '#title' => t('Page ID'),
    '#default_value' => $settings[0] != NULL ? FALSE : TRUE,
    '#disabled' => $settings[0] != NULL ? FALSE : TRUE,
    '#description' => $period[$settings[0]['lifetime']] . ' - ' . $router_item['page_id'],
  );
  $form['boost_db_rm_settings']['id_value'] = array(
    '#type' => 'hidden',
    '#title' => t('id_value'),
    '#default_value' => $settings[0] != NULL ? $settings[0]['csid'] : FALSE,
    '#disabled' => $settings[0] != NULL ? FALSE : TRUE,
  );
  $form['boost_db_rm_settings']['type'] = array(
    '#type' => 'checkbox',
    '#title' => t('Content Type'),
    '#default_value' => $settings[1] != NULL ? FALSE : TRUE,
    '#disabled' => $settings[1] != NULL ? FALSE : TRUE,
    '#description' => $period[$settings[1]['lifetime']] . ' - ' . $router_item['page_arguments'],
  );
  $form['boost_db_rm_settings']['type_value'] = array(
    '#type' => 'hidden',
    '#title' => t('type_value'),
    '#default_value' => $settings[1] != NULL ? $settings[1]['csid'] : FALSE,
    '#disabled' => $settings[1] != NULL ? FALSE : TRUE,
  );
  $form['boost_db_rm_settings']['container'] = array(
    '#type' => 'checkbox',
    '#title' => t('Content Container'),
    '#default_value' => $settings[2] != NULL ? FALSE : TRUE,
    '#disabled' => $settings[2] != NULL ? FALSE : TRUE,
    '#description' => $period[$settings[2]['lifetime']] . ' - ' . $router_item['page_callback'],
  );
  $form['boost_db_rm_settings']['container_value'] = array(
    '#type' => 'hidden',
    '#title' => t('container_value'),
    '#default_value' => $settings[2] != NULL ? $settings[2]['csid'] : FALSE,
    '#disabled' => $settings[2] != NULL ? FALSE : TRUE,
  );
  $form['boost_db_rm_settings']['send'] = array(
    '#type' => 'submit',
    '#value' => t('Delete Configuration'),
    '#submit' => array('boost_block_db_rm_settings_form_submit'),
    '#description' => t('Check the box to delete it'),
  );


  return $form;
}

/**
 * Sets page specific settings in the boost cache database.
 */
function boost_block_db_settings_form_submit(&$form_state, $form) {
  boost_set_db_page_settings($form['values']['lifetime'], $form['values']['push'], $form['values']['selection']);
}

/**
 * Sets page specific settings in the boost cache database.
 */
function boost_block_db_rm_settings_form_submit(&$form_state, $form) {
  if ($form['values']['id']) {
    boost_remove_settings_db($form['values']['id_value']);
  }
  if ($form['values']['type']) {
    boost_remove_settings_db($form['values']['type_value']);
  }
  if ($form['values']['container']) {
    boost_remove_settings_db($form['values']['container_value']);
  }
}


/**
 * Generate js/html for boost stat counter.
 *
 * NOTE HTML code could be added to the $buffer directly. Would prevent 2x
 * counts on first view. Would be hard to do though.
 *
 * @param $filename
 *   Name of boost's statistics php file.
 */
function boost_stats_generate($filename) {
  Global $base_path;

  // is node & node count enabled.
  if (arg(0) == 'node' && is_numeric(arg(1)) && arg(2) == '' && variable_get('statistics_count_content_views', 0)) {
    $nid = arg(1);;
  }
  else {
    $nid = 'NULL';
  }

  // access log enabled.
  if ((variable_get('statistics_enable_access_log', 0)) && (module_invoke('throttle', 'status') == 0)) {
    $title = drupal_urlencode(strip_tags(drupal_get_title()));
    $q = $_GET['q'];
  }
  else {
    $title = 'NULL';
    $q = 'NULL';
  }

  $page_js = array(
    'boost' => array(
      'nid' => $nid,
      'q' => $q,
      'title' => $title,
    ),
  );
  $site_js = <<<ETO
$.getJSON(Drupal.settings.basePath + "$filename", {nocache: "1", js: "1", nid: Drupal.settings.boost.nid, qq: Drupal.settings.boost.q, title: Drupal.settings.boost.title, referer: document.referrer}, function(response) {
  $.each(response, function(id, contents) {
    if (contents == 'NULL') {
      $(id).parent().parent().hide();
    }
    else {
      $(id).html(contents);
    }
  });
});
ETO;

  // page specific variables
  drupal_add_js($page_js, 'setting', 'header');
  // site-wide code
  drupal_add_js($site_js, 'inline', 'footer');
  // no script code
  $page_ns = '<noscript><div style="display:inline;"><img src="' . $base_path . $filename . '?nocache=1' . '&amp;nid='. $nid . '&amp;title='. $title . '&amp;q='. $q . '" alt="" /></div></noscript>';

  return $page_ns;
}

/**
 * Implementation of hook_theme().
 */
function boost_theme() {
  return array(
    'boost_cache_status' => array(
      'arguments' => array('ttl' => NULL, 'text' => NULL),
    ),
  );
}

function theme_boost_cache_status($ttl, $text) {
  return '<span class="boost cache-status" content="' . $ttl . '"><small>' . $text . '</small></span>';
}

//////////////////////////////////////////////////////////////////////////////
// Output buffering callback

/**
 * PHP output buffering callback for static page caching.
 *
 * NOTE: objects have already been destructed so $user is not available.
 *
 * @param $buffer
 *   Pages contents
 */
function _boost_ob_handler($buffer) {
  // Ensure we're in the correct working directory, since some web servers (e.g. Apache) mess this up here.
  chdir(dirname($_SERVER['SCRIPT_FILENAME']));

  if (function_exists('error_get_last')) {
    if (BOOST_HALT_ON_ERRORS && $error = error_get_last()) {
    switch ($error['type']) {
      case E_NOTICE: //Ignore run-time notices
      case E_USER_NOTICE: //Ignore user-generated notice message
      //case E_DEPRECATED: //Ignore run-time notices
      //case E_USER_DEPRECATED: //Ignore user-generated notice message
        break;
      default: //Do not cache page on all other errors
        if (BOOST_VERBOSE >= 3) {
          watchdog('boost', 'There are <strong>php errors</strong> on this page, preventing boost from caching. ERROR: <pre>%error</pre> !link <br /> !performance', array('%error' => boost_print_r($error, TRUE), '!link' => l(t('Lookup Error Type'), 'http://php.net/errorfunc.constants'), '!performance' => l(t('Turn Off Error Checking'), 'admin/settings/performance')), WATCHDOG_WARNING);
        }
        return $buffer;
      }
    }
  }
  if (BOOST_HALT_ON_ERRORS && $GLOBALS['_boost_message_count'] != 0) {
    if (BOOST_VERBOSE >= 3) {
      watchdog('boost', 'There are <strong>drupal messages</strong> on this page, preventing boost from caching. MESSAGES: %msg <br /> !performance', array('%msg' => $GLOBALS['_boost_message_count'], '!performance' => l(t('Turn Off Error Checking'), 'admin/settings/performance')), WATCHDOG_WARNING);
    }
    return $buffer;
  }


  // Check the currently set content type and the HTTP response code. We're
  // going to be exceedingly conservative here and only cache 'text' pages that
  // were output with a 200 OK status. If it didn't get a 200 then remove that
  // entry from the cache.
  if ($GLOBALS['_boost_cache_this'] && strlen($buffer) > 0) {
    switch (_boost_get_content_type()) {
      case 'text/html':
        if (_boost_get_http_status() == 200) {
          boost_cache_set($GLOBALS['_boost_path'], $buffer, BOOST_FILE_EXTENSION);
          boost_cache_css_js_files($buffer);
        }
        else {
//           boost_cache_expire_derivative($path);
//           $filename = boost_file_path($path, TRUE, BOOST_FILE_EXTENSION);
//           if ($filename) {
//             boost_cache_kill($filename);
//             boost_remove_db($filename);
//           }
        }
        break;
      case 'application/rss':
      case 'text/xml':
      case 'application/rss+xml':
        if (_boost_get_http_status() == 200) {
          boost_cache_set($GLOBALS['_boost_path'], $buffer, BOOST_XML_EXTENSION);
        }
        else {
//           boost_cache_expire_derivative($path);
//           $filename = boost_file_path($path, TRUE, BOOST_XML_EXTENSION);
//           if ($filename) {
//             boost_cache_kill($filename);
//             boost_remove_db($filename);
//           }
        }
        break;
      case 'text/javascript':
        if (_boost_get_http_status() == 200) {
          boost_cache_set($GLOBALS['_boost_path'], $buffer, BOOST_JSON_EXTENSION);
        }
        else {
//           boost_cache_expire_derivative($path);
//           $filename = boost_file_path($path, TRUE, BOOST_JSON_EXTENSION);
//           if ($filename) {
//             boost_cache_kill($filename);
//             boost_remove_db($filename);
//           }
        }
        break;
    }
  }

  // Allow the page request to finish up normally
  return $buffer;
}

/**
 * Determines the MIME content type of the current page response based on
 * the currently set Content-Type HTTP header.
 *
 * This should normally return the string 'text/html' unless another module
 * has overridden the content type.
 *
 * @param $default
 *   Return this value if it can't be found
 */
function _boost_get_content_type($default = NULL) {
  static $regex = '!^Content-Type:\s*([\w\d\/\-]+)!i';
  return _boost_get_http_header($regex, $default);
}

/**
 * Determines the HTTP response code that the current page request will be
 * returning by examining the HTTP headers that have been output so far.
 *
 * @param $default
 *   Look for a 200 status
 */
function _boost_get_http_status($default = 200) {
  static $regex = '!^HTTP/1.1\s+(\d+)!';
  return (int)_boost_get_http_header($regex, $default);
}

/**
 * Get HTTP header
 *
 * @param $regex
 *   Regular expression to get HTTP Header Line
 * @param $default
 *   Return this value if it can't be found
 */
function _boost_get_http_header($regex, $default = NULL) {
  // The last header is the one that counts:
  $headers = preg_grep($regex, explode("\n", drupal_get_headers()));
  if (!empty($headers) && preg_match($regex, array_pop($headers), $matches)) {
    return $matches[1]; // found it
  }
  return $default; // no such luck
}

//////////////////////////////////////////////////////////////////////////////
// Boost API implementation

/**
 * Determines whether a given Drupal page can be cached or not.
 *
 * To avoid potentially troublesome situations, the user login page is never
 * cached, nor are any admin pages.
 *
 * @param $path
 *   Current URL
 *
 * $path = $GLOBALS['_boost_path'] most of the time
 */
function boost_is_cacheable($path) {
  $path = (empty($path)) ? variable_get('site_frontpage', 'node') : $path;
  $normal_path = drupal_get_normal_path($path); // normalize path

  // Never cache the basic user login/registration pages or any administration pages
  // RSS feeds are not cacheable due to content type restrictions
  // Don't cache comment reply pages
  // Under no circumstances should the incoming path contain '..' or null
  // bytes; we also limit the maximum directory nesting depth of the path
  if (   $normal_path == 'user'
      || preg_match('!^user/(login|register|password)!', $normal_path)
      || preg_match('!^admin!', $normal_path)
      || preg_match('!comment/reply$!', $normal_path)
      || preg_match('!^node/add!', $normal_path)
      || strpos($path, '..') !== FALSE
      || strpos($path, "\0") !== FALSE
      || count(explode('/', $path)) > BOOST_MAX_PATH_DEPTH
    ) {
    return FALSE;
  }
  if (!BOOST_CACHE_XML && (preg_match('!/feed$!', $normal_path) || preg_match('!\.xml$!', $normal_path))) {
    return FALSE;
  }
  if (!BOOST_CACHE_QUERY && $GLOBALS['_boost_query'] != BOOST_CHAR) {
    return FALSE;
  }

  // Don't cache path if it can't be served by apache.
  if (BOOST_ONLY_ASCII_PATH) {
    if (preg_match('@[^/a-z0-9_\-&=,\.:]@i', $path)) {
      return FALSE;
    }
  }

  // Check for reserved characters if on windows
  // http://en.wikipedia.org/wiki/Filename#Reserved_characters_and_words
  // " * : < > |
  $chars = '"*:<>|';
  if (stristr(PHP_OS, 'WIN') && preg_match("/[".$chars."]/", $normal_path)) {
    return FALSE;
  }

  // See http://api.drupal.org/api/function/block_list/6
  // Match the user's cacheability settings against the path
  if (BOOST_CACHEABILITY_PAGES) {
    if (BOOST_CACHEABILITY_OPTION < 2) {
      $page_match = drupal_match_path($path, BOOST_CACHEABILITY_PAGES);
      if ($path != $_GET['q']) {
        $page_match = $page_match || drupal_match_path($_GET['q'], BOOST_CACHEABILITY_PAGES);
      }
      // When BOOST_CACHEABILITY_OPTION has a value of 0, boost will cache
      // all pages except those listed in BOOST_CACHEABILITY_PAGES. When set
      // to 1, boost will cache only on those pages listed in BOOST_CACHEABILITY_PAGES.
      $page_match =  !(BOOST_CACHEABILITY_OPTION xor $page_match);
    }
    else {
      $page_match =  drupal_eval(BOOST_CACHEABILITY_PAGES);
    }
  }
  else {
    $page_match =  TRUE;
  }
  return $page_match;
}

/**
 * Determines whether a given Drupal page is currently cached or not.
 *
 * @param $path
 *   Current URL
 */
function boost_is_cached($path) {
  // no more need to check if path is empty cause it is done on the input of this function before calling it
  // no more need to use drupal_get_normal_path - we do not need the internal path (node/56) - we are fine with aliases
  return file_exists(boost_file_path($path));
}

/**
 * Deletes all files currently in the cache.
 */
function boost_cache_clear_all() {
  if (BOOST_IGNORE_FLUSH == 0) {
    boost_cache_clear_all_db();
    boost_cache_delete(TRUE);
    if (BOOST_VERBOSE >= 5) {
      watchdog('boost', 'Flushed ALL files from static page cache.', array(), WATCHDOG_NOTICE);
    }
    return TRUE;
  }
  return FALSE;
}

/**
 * Deletes all expired static files currently in the cache.
 * OLD FUNCTION
 */
function boost_cache_expire_all() {
  boost_cache_delete(FALSE);
  return TRUE;
}

/**
 * Resets all entries in database.
 */
function boost_cache_clear_all_db() {
  db_query("UPDATE {boost_cache} SET expire = %d WHERE base_dir = '%s'", 0, BOOST_FILE_PATH);
}

/**
 * Deletes files in the cache.
 *
 * @param $flush
 *   If true clear the entire cache directory.
 */
function boost_cache_delete($flush = FALSE) {
  clearstatcache();

  //recreate dirs
  _boost_mkdir_p(BOOST_FILE_PATH);
  _boost_mkdir_p(BOOST_GZIP_FILE_PATH);
  //add in .boost root id file
  file_put_contents(BOOST_FILE_PATH . '/' . BOOST_ROOT_FILE, BOOST_FILE_PATH);
  file_put_contents(BOOST_GZIP_FILE_PATH . '/' . BOOST_ROOT_FILE, BOOST_GZIP_FILE_PATH);

  //Flush Cache
  if (file_exists(BOOST_FILE_PATH)) {
    _boost_rmdir_rf(BOOST_FILE_PATH, $flush, TRUE);
  }
  if (file_exists(BOOST_GZIP_FILE_PATH)) {
    _boost_rmdir_rf(BOOST_GZIP_FILE_PATH, $flush, TRUE);
  }

  //recreate dirs
  _boost_mkdir_p(BOOST_FILE_PATH);
  _boost_mkdir_p(BOOST_GZIP_FILE_PATH);
  //add in .boost root id file
  file_put_contents(BOOST_FILE_PATH . '/' . BOOST_ROOT_FILE, BOOST_FILE_PATH);
  file_put_contents(BOOST_GZIP_FILE_PATH . '/' . BOOST_ROOT_FILE, BOOST_GZIP_FILE_PATH);
}

/**
 * Finds all possible paths/redirects/aliases given the root path.
 *
 * @param $path
 *   Current URL
 * @param $wildcard
 *   If true get all chached files that start with this path.
 */
function boost_cache_expire_derivative($path, $wildcard = FALSE) {
  global $base_path;
  //path alias
  $path_alias = url($path, array('absolute' => FALSE));
  if ($base_path != '/') {
    $path_alias = implode('/', array_diff_assoc(array_filter(explode('/', $path_alias)), array_filter(explode('/', $base_path))));
  }

  //path redirects
  if (module_exists('path_redirect')) {
    $path_redirects = boost_path_redirect_load(array('redirect' => $path));
  }

  //flush caches
  boost_cache_expire($path_alias, $wildcard);
  if (isset($path_redirects)) {
    foreach ($path_redirects as $path_redirect) {
      boost_cache_expire($path_redirect['path'], $wildcard);
    }
  }
  boost_cache_expire($path, $wildcard);
}

/**
 * Expires the static file cache for a given page, or multiple pages
 * matching a wildcard.
 *
 * @param $path
 *   Current URL
 * @param $wildcard
 *   If true get all chached files that start with this path.
 *
 * TODO: Replace glob() with a database operation.
 */
function boost_cache_expire($path, $wildcard = FALSE) {
  // Sanity check
  if (boost_file_path($path, FALSE) === FALSE) {
    return FALSE;
  }

  // Get list of related files
  $tempA = glob(boost_file_path($path, FALSE, NULL) . (($wildcard) ? '*' : '') . BOOST_FILE_EXTENSION, GLOB_NOSORT);
  $tempB = glob(boost_file_path($path, FALSE, NULL) . (($wildcard) ? '*' : '') . BOOST_XML_EXTENSION, GLOB_NOSORT);
  if (!empty($tempA) && !empty($tempB)) {
    $filenames = array_filter(array_merge($tempA, $tempB));
  }
  elseif (!empty($tempA)) {
    $filenames = $tempA;
  }
  elseif (!empty($tempB)) {
    $filenames = $tempB;
  }
  else {
    return FALSE;
  }
  if (empty($filenames)) {
    return FALSE;
  }

  // Flush expired files
  foreach ($filenames as $filename) {
    boost_cache_kill($filename);
  }
  return TRUE;
}

/**
 * Deletes cached page from file system
 *
 * @param $filename
 *   Name of cached file; primary key in database
 */
function boost_cache_kill($filename) {
  if (BOOST_IGNORE_FLUSH < 3 && strstr($filename, BOOST_FILE_PATH)) {
    db_query("UPDATE {boost_cache} SET expire = 0 WHERE filename = '%s'", $filename);
    if (file_exists($filename)) {
      @unlink($filename);
    }
    $gz_filename = str_replace(BOOST_FILE_PATH, BOOST_GZIP_FILE_PATH, $filename) . BOOST_GZIP_EXTENSION;
    if (file_exists($gz_filename)) {
      @unlink($gz_filename);
    }
  }
}

 /**
 * Flushes all expired pages from database
 *
 * TODO del empty dirs if enabled
 */
function boost_cache_db_expire() {
  if (BOOST_IGNORE_FLUSH < 2) {
    $result = db_query('SELECT filename FROM {boost_cache} WHERE expire BETWEEN 1 AND %d', BOOST_TIME);
    while ($boost = db_fetch_array($result)) {
      boost_cache_kill($boost['filename']);
    }
    if (BOOST_FLUSH_DIR) {
      // TO-DO: del empty dirs.
    }
    return TRUE;
  }
  return FALSE;
}

/**
 * Returns the cached contents of the specified page, if available.
 *
 * @param $path
 *   Current URL
 */
function boost_cache_get($path) {
  if (($filename = boost_file_path($path))) {
    if (file_exists($filename) && is_readable($filename)) {
      return file_get_contents($filename);
    }
  }

  return NULL;
}


/**
 * Replaces/Sets the cached contents of the specified page, if stale.
 *
 * @param $path
 *   Current URL
 * @param $data
 *   URL's contents
 * @param $extension
 *   File extension for this mime type
 */
function boost_cache_set($path, $data = '', $extension = BOOST_FILE_EXTENSION) {
  // Code commenting style based on what is being cached.
  switch ($extension) {
    case BOOST_FILE_EXTENSION:
      if (!BOOST_CACHE_HTML) {
        return FALSE;
      }
      $comment_start = '<!-- ';
      $comment_end = " -->\n";
      $expire = BOOST_CACHE_LIFETIME;
      break;
    case BOOST_XML_EXTENSION:
      if (!BOOST_CACHE_XML) {
        return FALSE;
      }
      $comment_start = '<!-- ';
      $comment_end = " -->\n";
      $expire = BOOST_CACHE_XML_LIFETIME;
      break;
    case BOOST_JSON_EXTENSION:
      if (!BOOST_CACHE_JSON) {
        return FALSE;
      }
      $comment_start = '/* ';
      $comment_end = " */\n";
      $expire = BOOST_CACHE_JSON_LIFETIME;
      break;
  }
  // Append the Boost footer with the relevant timestamps
  $cached_at = date('Y-m-d H:i:s', BOOST_TIME);
  $expires_at = date('Y-m-d H:i:s', BOOST_TIME + $expire);
  $data = rtrim($data) . "\n" . $comment_start . str_replace(array('%cached_at', '%expires_at'), array($cached_at, $expires_at), BOOST_BANNER) . $comment_end;

  // Invoke hook_boost_preprocess($path, $data)
  foreach (module_implements('boost_preprocess') as $module) {
    if (($result = module_invoke($module, $path, $data)) != NULL) {
      $data = $result;
    }
  }

  // Execute the pre-process function if one has been defined
  if (function_exists(BOOST_PRE_PROCESS_FUNCTION)) {
    $data = call_user_func(BOOST_PRE_PROCESS_FUNCTION, $data);
  }
  db_set_active();

  // Create or update the static files as needed
  if (($filename = boost_file_path($path, TRUE, $extension)) && (BOOST_OVERWRITE_FILE || !file_exists($filename) || boost_db_is_expired($filename))) {
    // Special handling of the front page for aggressive gzip test
    if ($path == '' && BOOST_AGGRESSIVE_GZIP) {
      _boost_generate_gzip_test();
      boost_cache_write($filename, _boost_gzip_test_inject_iframe($data));
    }
    else {
      boost_cache_write($filename, $data);
    }
    if (BOOST_GZIP) {
      boost_cache_write(str_replace(BOOST_FILE_PATH, BOOST_GZIP_FILE_PATH, $filename) . BOOST_GZIP_EXTENSION, gzencode($data, 9));
    }
    boost_db_prep($filename, $extension, BOOST_TIME + $expire);
    return TRUE;
  }
  else {
    return FALSE;
  }
}

/**
 * Figure out what is going in the database & put it in
 *
 * @param $filename
 *   Name of cached file; primary key in database
 * @param $extension
 *  Filename extension: Used for content types.
 * @param $expire
 *  Cache expiration time in seconds (UNIX time).
 */
function boost_db_prep($filename, $extension, $expire) {
  $router_item = _boost_get_menu_router();
  $timer = timer_read('page');
  $timer_average = $timer;
  $lifetime = -1;
  $push = -1;

  $settings = boost_get_settings_db($router_item);
  foreach ($settings as $value) {
    if ($value != NULL) {
      $boost_settings_db = $value;
      break;
    }
  }
  $boost_db = boost_get_db($filename);
  //get time data from actual entry, if this page has been cached before.
  if ($boost_db) {
  //  $expire = $boost_db['lifetime'] != -1 ? $boost_db['lifetime'] + BOOST_TIME : $expire;
  //  $lifetime = $boost_db['lifetime'];
  //  $push = $boost_db['push'];
    $timer_average = ($boost_db['timer_average'] + $timer)/2;
  }
  //get data from settings table, if this page has not been put into the cache.
  if (isset($boost_settings_db)) {
    $expire = $boost_settings_db['lifetime'] != -1 ? $boost_settings_db['lifetime'] + BOOST_TIME : $expire;
    $lifetime = $boost_settings_db['lifetime'];
    $push = $boost_settings_db['push'];
  }

  boost_put_db($filename, $expire, $lifetime, $push, $router_item, $timer, $timer_average, $extension);
}

/**
 * Puts boost info into database.
 *
 * @param $filename
 *   Name of cached file; primary key in database
 * @param $expire
 *   Expiration time
 * @param $lifetime
 *   Default lifetime
 * @param $push
 *   Pre-cache this file
 * @param $router_item
 *   Array containing page_callback, page_arguments & page_id.
 * @param $timer
 *   Time it took drupal to build this page.
 * @param $timer_average
 *   Average time Drupal has spent building this page.
 * @param $extension
 *   Filename extension: Used for content types.
 */
function boost_put_db($filename, $expire, $lifetime, $push, $router_item, $timer, $timer_average, $extension) {
  global $base_root;
  $url = $base_root . request_uri();
  db_query("UPDATE {boost_cache} SET expire = %d, lifetime = %d, push = %d, page_callback = '%s', page_arguments = '%s', timer = %d, timer_average = %d, base_dir = '%s', page_id = %d, extension = '%s', url = '%s' WHERE filename = '%s'", $expire, $lifetime, $push, $router_item['page_callback'], $router_item['page_arguments'], $timer, $timer_average, BOOST_FILE_PATH, $router_item['page_id'], $extension, $url, $filename);
  if (!db_affected_rows()) {
    db_query("INSERT INTO {boost_cache} (filename, expire, lifetime, push, page_callback, page_arguments, timer, timer_average, base_dir, page_id, extension, url) VALUES ('%s', %d, %d, %d, '%s', '%s', %d, %d, '%s', %d, '%s', '%s')", $filename, $expire, $lifetime, $push, $router_item['page_callback'], $router_item['page_arguments'], $timer, $timer_average, BOOST_FILE_PATH, $router_item['page_id'], $extension, $url);
  }
}

/**
 * Removes info from database. Use on 404 or 403.
 *
 * @param $filename
 *   Name of cached file; primary key in database
 */
function boost_remove_db($filename) {
  if (strstr($filename, BOOST_FILE_PATH)) {
    db_query("DELETE FROM {boost_cache} WHERE filename = '%s'", $filename);
  }
}

/**
 * Puts boost info into database.
 *
 * @param $filename
 *   Name of cached file; primary key in database
 * @param $expire
 *   Expiration time
 * @param $lifetime
 *   Default lifetime
 * @param $push
 *   Pre-cache this file
 * @param $router_item
 *   Array containing page_callback, page_arguments & page_id.
 */
function boost_put_settings_db($lifetime, $push, $router_item, $scope) {
  switch ($scope) {
    case 0:
      db_query("UPDATE {boost_cache_settings} SET lifetime = %d, push = %d WHERE page_callback = '%s' AND page_arguments = '%s' AND base_dir = '%s' AND page_id = %d", $lifetime, $push, $router_item['page_callback'], $router_item['page_arguments'], BOOST_FILE_PATH, $router_item['page_id']);
      if (!db_affected_rows()) {
        @db_query("INSERT INTO {boost_cache_settings} (csid, lifetime, push, page_callback, page_arguments, base_dir, page_id) VALUES (NULL, %d, %d, '%s', '%s', '%s', %d)", $lifetime, $push, $router_item['page_callback'], $router_item['page_arguments'], BOOST_FILE_PATH, $router_item['page_id']);
      }
      break;
    case 1:
      db_query("UPDATE {boost_cache_settings} SET lifetime = %d, push = %d WHERE page_callback = '%s' AND page_arguments = '%s' AND base_dir = '%s' AND page_id = 0", $lifetime, $push, $router_item['page_callback'], $router_item['page_arguments'], BOOST_FILE_PATH);
      if (!db_affected_rows()) {
        @db_query("INSERT INTO {boost_cache_settings} (csid, lifetime, push, page_callback, page_arguments, base_dir, page_id) VALUES (NULL, %d, %d, '%s', '%s', '%s', %d)", $lifetime, $push, $router_item['page_callback'], $router_item['page_arguments'], BOOST_FILE_PATH, 0);
      }
      break;
    case 2:
      db_query("UPDATE {boost_cache_settings} SET lifetime = %d, push = %d WHERE page_callback = '%s' AND page_arguments = '0' AND base_dir = '%s' AND page_id = 0", $lifetime, $push, $router_item['page_callback'], BOOST_FILE_PATH);
      if (!db_affected_rows()) {
        @db_query("INSERT INTO {boost_cache_settings} (csid, lifetime, push, page_callback, page_arguments, base_dir, page_id) VALUES (NULL, %d, %d, '%s', '%s', '%s', %d)", $lifetime, $push, $router_item['page_callback'], '0', BOOST_FILE_PATH, 0);
      }
      break;
  }
}

/**
 * Removes info from boost database.
 *
 * @param $filename
 *   Name of cached file; primary key in database
 * @param $expire
 *   Expiration time
 * @param $lifetime
 *   Default lifetime
 * @param $push
 *   Pre-cache this file
 * @param $router_item
 *   Array containing page_callback, page_arguments & page_id.
 */
function boost_remove_settings_db($csid) {
  db_query("DELETE FROM {boost_cache_settings} WHERE csid = %d", $csid);
}

/**
 * Sets per page configuration.
 *
 * @param $lifetime
 *   Default lifetime
 * @param $push
 *   Pre-cache this file
 */
function boost_set_db_page_settings($lifetime, $push, $scope) {
  $router_item = _boost_get_menu_router();
  $filename = boost_file_path($GLOBALS['_boost_path']);
  $info = boost_get_db($filename);
  if (!$info) {
    $info['expire'] = 0;
  }
  elseif ($lifetime == -1) {
    $info['expire'] = $info['expire'] - $info['lifetime'] + BOOST_CACHE_LIFETIME;
  }
  elseif ($info['lifetime'] == -1) {
    $info['expire'] = $info['expire'] - BOOST_CACHE_LIFETIME + $lifetime;
  }
  elseif ($info['lifetime'] != $lifetime) {
    $info['expire'] = $info['expire'] - $info['lifetime'] + $lifetime;
  }

  // Clear old files so they acquire the new settings.
  boost_cache_expire_derivative($GLOBALS['_boost_path']);
  //boost_put_db($filename, $info['expire'], $lifetime, $push, $router_item);
  boost_put_settings_db($lifetime, $push, $router_item, $scope);
}

/**
 * Gets boost info from cache database.
 *
 * @param $filename
 *   Filename to be looked up in the database
 */
function boost_get_db($filename) {
  return db_fetch_array(db_query_range("SELECT * FROM {boost_cache} WHERE filename = '%s'", $filename, 0, 1));
}

/**
 * Gets boost settings from cache settings database.
 *
 * @param $router_item
 *   Array containing page_callback, page_arguments & page_id.
 */
function boost_get_settings_db($router_item) {
  $settings = array();
  // Get a more exact match first
  $settings[] = db_fetch_array(db_query_range("SELECT * FROM {boost_cache_settings} WHERE page_callback = '%s' AND page_arguments = '%s' AND base_dir = '%s' AND page_id = %d", $router_item['page_callback'], $router_item['page_arguments'], BOOST_FILE_PATH, $router_item['page_id'], 0, 1));

  // Get for the content type
  $settings[] = db_fetch_array(db_query_range("SELECT * FROM {boost_cache_settings} WHERE page_callback = '%s' AND page_arguments = '%s' AND base_dir = '%s' AND page_id = %d", $router_item['page_callback'], $router_item['page_arguments'], BOOST_FILE_PATH, 0, 0, 1));

  // Finally get the content container (node, view, term, ect...)
  $settings[] = db_fetch_array(db_query_range("SELECT * FROM {boost_cache_settings} WHERE page_callback = '%s' AND page_arguments = '%s' AND base_dir = '%s' AND page_id = %d", $router_item['page_callback'], 0, BOOST_FILE_PATH, 0, 0, 1));

  return $settings;
}

/**
 * Returns all cached pages associated with the taxonomy term.
 */
function boost_get_db_term($term) {
 $filenames = array();
 $result = db_query("SELECT filename FROM {boost_cache} WHERE expire > 0 AND page_id = %d AND page_callback = 'taxonomy'", $term);
 while ($filename = db_fetch_array($result)) {
    $filenames[] = $filename['filename'];
  }
  return $filenames;
}

/**
 * Checks various timestamps in the database.
 *
 * @return bool
 *  Returns TRUE if the site has changed since the last time this function was called.
 */
function boost_has_site_changed() {

  // Get timestamps from the database
  $node_revisions = boost_get_time('node_revisions', 'timestamp');
  $history = boost_get_time('history', 'timestamp');
  $files = boost_get_time('files', 'timestamp');
  $comments = boost_get_time('comments', 'timestamp');
  $node = boost_get_time('node', 'changed');
  $last_comment_timestamp = boost_get_time('node_comment_statistics', 'last_comment_timestamp');

  $max = max($node_revisions, $history, $files, $comments, $node, $last_comment_timestamp);
  if ($max != BOOST_MAX_TIMESTAMP) {
    variable_set('boost_max_timestamp', $max);
    return TRUE;
  }
  else {
    return FALSE;
  }
}

/**
 * Checks various timestamps in the database.
 *
 * @param $table
 *  Database table name
 * @param $column
 *  Column containing the time stamp
 * @return int
 *  Returns largest time in the table.
 */
function boost_get_time($table, $column) {
  if (db_result(db_query("SHOW TABLES LIKE '%s'", $table))) {
    return db_result(db_query_range("SELECT %s FROM {%s} ORDER BY %s DESC", $column, $table, $column, 0, 1));
  }
  else {
    return 0;
  }
}

/**
 * Writes data to filename in an atomic operation thats compatible with older
 * versions of php (php < 5.2.4 file_put_contents() doesn't lock correctly).
 *
 * @param $filename
 *   Name of file to be written
 * @param $data
 *   Contents of file
 */
function boost_cache_write($filename, $data = '') {
  if (!_boost_mkdir_p(dirname($filename))) {
    if (BOOST_VERBOSE >= 3) {
      watchdog('boost', 'Unable to create directory: %dir<br /> Group ID: %gid<br /> User ID: %uid<br /> Current script owner: %user<br />', array('%dir' => dirname($filename), '%gid' => getmygid(), '%uid' => getmyuid(), '%user' => get_current_user()), WATCHDOG_WARNING);
    }
  }
  $tempfile = $filename . getmypid();
  if (@file_put_contents($tempfile, $data) === FALSE) {
    if (BOOST_VERBOSE >= 3) {
      watchdog('boost', 'Unable to write temp file: %file<br /> Group ID: %gid<br /> User ID: %uid<br /> Current script owner: %user<br />', array('%file' => $tempfile, '%gid' => getmygid(), '%uid' => getmyuid(), '%user' => get_current_user()), WATCHDOG_WARNING);
    }
    return FALSE;
  }
  else {
    if (is_numeric(BOOST_PERMISSIONS_FILE)) {
      @chmod($tempfile, octdec(BOOST_PERMISSIONS_FILE));
    }
    // put the temp file in its final location
    if (@rename($tempfile, $filename) === FALSE) {
      if (BOOST_VERBOSE >= 5) {
        watchdog('boost', 'Unable to rename file: %temp  to  %file<br /> Group ID: %gid<br /> User ID: %uid<br /> Current script owner: %user<br />', array('%temp' => $tempfile, '%file' => $filename, '%gid' => getmygid(), '%uid' => getmyuid(), '%user' => get_current_user()), WATCHDOG_WARNING);
      }
      @unlink($tempfile);
      return FALSE;
    }
  }
  return TRUE;
}

/**
 * Returns the full directory path to the static file cache directory.
 *
 * @param $host
 *   Host name. Example: example.com
 * @param $absolute
 *   Give path from system root if true. If false give path from web root.
 */
function boost_cache_directory($host = NULL, $absolute = TRUE) {
  global $base_url;
  if ($base_url == "http://") {
    if (BOOST_VERBOSE >= 1) {
      watchdog('boost', 'base_url is not set in your settings.php file. Please read #7 in boosts INSTALL.txt file.', array(), WATCHDOG_NOTICE);
    }
    if (!BOOST_MULTISITE_SINGLE_DB) {
      $base_url = $base_url . str_replace(BOOST_ROOT_CACHE_DIR . '/', '', variable_get('boost_file_path', boost_cache_directory(NULL, FALSE)));
    }
  }
  $parts = parse_url($base_url);
  $host = !empty($host) ? $host : $parts['host'];
  $parts['path'] = isset($parts['path']) ? $parts['path'] : '/';
  $subdir = implode('/', array_filter(explode('/', (!empty($base_path)) ? $base_path : $parts['path'])));

  return implode('/', !$absolute ? array_filter(array(BOOST_ROOT_CACHE_DIR, BOOST_NORMAL_DIR, $host, $subdir)) : array_filter(array(getcwd(), BOOST_ROOT_CACHE_DIR, BOOST_NORMAL_DIR, $host, $subdir)));
}

/**
 * Returns the static file path for a Drupal page.
 *
 * @param $path
 *   path to convert to boost's file naming convention
 * @param $query
 *   add query to path
 * @param $extension
 *   add extension to end of filename
 *
 * $path = $GLOBALS['_boost_path'] most of the time
 */
function boost_file_path($path, $query = TRUE, $extension = BOOST_FILE_EXTENSION) {
  //handling of url variables
  if ($GLOBALS['_boost_query'] != BOOST_CHAR) {
    if ($query) {
      $path .= $GLOBALS['_boost_query'];
    }
  }
  else {
    $path .= $GLOBALS['_boost_query'];
  }

  // Under no circumstances should the incoming path contain '..' or null
  // bytes; we also limit the maximum directory nesting depth of the path
  if (   strpos($path, '..') !== FALSE
      || strpos($path, "\0") !== FALSE
      || count(explode('/', $path)) > BOOST_MAX_PATH_DEPTH
      ) {
    return FALSE;
  }

  return implode('/', array(BOOST_FILE_PATH, $path . (is_null($extension) ? '' : $extension)));
}

/**
 * Returns the age of a cached file, measured in seconds since it was last
 * updated.
 * @param $filename
 *   Name of cached file
 */
function boost_file_get_age($filename) {
  return BOOST_TIME - filemtime($filename);
}
function boost_db_get_age($filename) {
  $boost_db = boost_get_db($filename);
  return $boost_db['expire'] != 0 ? $boost_db['expire'] : FALSE;
}

/**
 * Returns the remaining time-to-live for a cached file, measured in
 * seconds.
 * @param $filename
 *   Name of cached file
 */
function boost_file_get_ttl($filename) {
  return BOOST_CACHE_LIFETIME - boost_file_get_age($filename);
}
function boost_db_get_ttl($filename) {
  $boost_db = boost_get_db($filename);
  return boost_db_get_age($filename) - BOOST_TIME;
}

/**
 * Determines whether a cached file has expired, i.e. whether its age
 * exceeds the maximum cache lifetime as defined by Drupal's system
 * settings.
 * @param $filename
 *   Name of cached file
 */
function boost_file_is_expired($filename) {
  return boost_file_get_age($filename) > BOOST_CACHE_LIFETIME;
}
function boost_db_is_expired($filename) {
  return boost_db_get_age($filename) < BOOST_TIME;
}

/**
 * Sets a special cookie preventing authenticated users getting served pages
 * from the static page cache.
 *
 * @param $user
 *   User Object
 * @param $expires
 *   Expiration time
 */
function boost_set_cookie($user, $expires = NULL) {
  if (!$expires) {
    $expires = ini_get('session.cookie_lifetime');
    $expires = (!empty($expires) && is_numeric($expires)) ? BOOST_TIME + (int)$expires : 0;
    setcookie(BOOST_COOKIE, $user->uid, $expires, ini_get('session.cookie_path'), ini_get('session.cookie_domain'), ini_get('session.cookie_secure') == '1');
  }
  else {
    setcookie(BOOST_COOKIE, FALSE, $expires, ini_get('session.cookie_path'), ini_get('session.cookie_domain'), ini_get('session.cookie_secure') == '1');
  }
  $GLOBALS['_boost_cache_this'] = FALSE;
}

/**
 * Retrieve a specific URL redirect from the database.
 * http://drupal.org/node/451790
 *
 * @param $where
 *   Array containing 'redirect' => $path
 */
function boost_path_redirect_load($where = array(), $args = array(), $sort = array()) {
  $redirects = array();
  if (is_numeric($where)) {
    $where = array('rid' => $where);
  }

  foreach ($where as $key => $value) {
    if (is_string($key)) {
      $args[] = $value;
      $where[$key] = $key .' = '. (is_numeric($value) ? '%d' : "'%s'");
    }
  }

  if ($where && $args) {
    $sql = "SELECT * FROM {path_redirect} WHERE ". implode(' AND ', $where);
    if ($sort) {
      $sql .= ' ORDER BY '. implode(' ,', $sort);
    }
    $result = db_query($sql, $args);
    while ($redirect = db_fetch_array($result)) {
      $redirects[] = $redirect;
    }
    return $redirects;
  }
}

/**
 * Cache css and or js files.
 *
 * Parse the html file so we get all css/js files. drupal_get_js/css isn't 100%.
 *
 * @param $buffer
 *   String containing documents html.
 */
function boost_cache_css_js_files($buffer) {
  if (BOOST_CACHE_CSS) {
    // Extract external css files from html document
    $css = explode('<link type="text/css" rel="stylesheet" ', $buffer);
    array_shift($css);
    foreach ($css as $key => $value) {
      // Only grab the first string, containing the css filename.
      $css[$key] = array_shift(explode(' />', $value));
    }
    $css = implode('',$css);

    _boost_copy_css_files($css);
  }
  if (BOOST_CACHE_JS) {
    $js = explode('<script type="text/javascript" ', $buffer);
    array_shift($js);
    $temp = explode('</script>', array_pop($js));
    $js[] = array_shift($temp);
    $js = implode('',$js);
    _boost_copy_js_files($js);
  }
}

/**
 * An alternative to print_r that unlike the original does not use output buffering with
 * the return parameter set to true. Thus, Fatal errors that would be the result of print_r
 * in return-mode within ob handlers can be avoided.
 * http://php.net/print-r#75872
 *
 * Comes with an extra parameter to be able to generate html code. If you need a
 * human readable DHTML-based print_r alternative, see http://krumo.sourceforge.net/
 *
 * Support for printing of objects as well as the $return parameter functionality
 * added by Fredrik Wollsn (fredrik dot motin at gmail), to make it work as a drop-in
 * replacement for print_r (Except for that this function does not output
 * parenthesis around element groups... ;) )
 *
 * Based on return_array() By Matthew Ruivo (mruivo at gmail)
 * (http://www.php.net/manual/en/function.print-r.php#73436)
 */
function boost_print_r($var, $return = false, $html = false, $level = 0) {
  $spaces = "";
  $space = $html ? "&nbsp;" : " ";
  $newline = $html ? "<br />" : "\n";
  for ($i = 1; $i <= 6; $i++) {
    $spaces .= $space;
  }
  $tabs = $spaces;
  for ($i = 1; $i <= $level; $i++) {
    $tabs .= $spaces;
  }
  if (is_array($var)) {
    $title = "Array";
  }
  elseif (is_object($var)) {
    $title = get_class($var)." Object";
  }
  $output = $title . $newline . $newline;

  // Recursive boost_print_r
  foreach($var as $key => $value) {
    if (is_array($value) || is_object($value)) {
      $level++;
      $value = boost_print_r($value, true, $html, $level);
      $level--;
    }
    $output .= $tabs . "[" . $key . "] => " . $value . $newline;
  }

  if ($return) {
    return $output;
  }
  else {
    echo $output;
  }
}

/**
 * Alt to Drupal's url() function.
 * @see http://drupal.org/node/513860
 *
 * http://php.net/parse-url#85963
 */
function boost_glue_url($parsed) {
  if (!is_array($parsed)) {
    return false;
  }

  $uri = isset($parsed['scheme']) ? $parsed['scheme'] . ':' . ((strtolower($parsed['scheme']) == 'mailto') ? '' : '//') : '';
  $uri .= isset($parsed['user']) ? $parsed['user'] . (isset($parsed['pass']) ? ': ' . $parsed['pass'] : '') . '@' : '';
  $uri .= isset($parsed['host']) ? $parsed['host'] : '';
  $uri .= isset($parsed['port']) ? ':' . $parsed['port'] : '';

  if (isset($parsed['path'])) {
    $uri .= (substr($parsed['path'], 0, 1) == '/') ? $parsed['path'] : ((!empty($uri) ? '/' : '' ) . $parsed['path']);
  }

  $uri .= isset($parsed['query']) ? '?' . $parsed['query'] : '';
  $uri .= isset($parsed['fragment']) ? '#' . $parsed['fragment'] : '';

  return $uri;
}

//////////////////////////////////////////////////////////////////////////////
// Boost API internals
/**
 * Extract css filenames from html and copy them & their children.
 *
 * @param $css
 *   String containing all html css.
 */
function _boost_copy_css_files($css) {
  //extract css file name
  $css_files=explode('href="', $css);
  array_shift($css_files);
  for ($i = 0; $i < count($css_files); $i++) {
    $temp = array_pop(explode('//', $css_files[$i]));
    $temp = explode(base_path(), array_shift(explode('.css', $temp)));
    array_shift($temp);
    $css_files[$i] = implode(base_path(), $temp);
  }

  //copy files
  foreach ($css_files as $css_file) {
    if (file_exists($css_file . '.css')) {
      $src = $css_file . '.css';
      $dest = BOOST_PERM_FILE_PATH . '/' . $css_file . '.css' . BOOST_PERM_CHAR . BOOST_CSS_EXTENSION;
      _boost_copy_file($src, $dest);
    }
    if (file_exists($css_file . '.css.gz')) {
      $src = $css_file . '.css.gz';
      $dest = BOOST_PERM_GZIP_FILE_PATH . '/' . $css_file . '.css' . BOOST_PERM_CHAR . BOOST_CSS_EXTENSION . BOOST_GZIP_EXTENSION;
      _boost_copy_file($src, $dest);
    }
    elseif (BOOST_GZIP && file_exists($css_file . '.css')) {
      $src = $css_file . '.css';
      $dest = BOOST_PERM_GZIP_FILE_PATH . '/' . $css_file . '.css' . BOOST_PERM_CHAR . BOOST_CSS_EXTENSION . BOOST_GZIP_EXTENSION;
      _boost_gz_copy_file($src, $dest);
    }
  }
}

/**
 * Extract javascript filenames from html and copy them & their children.
 *
 * @param $js
 *   String containing all html javascript.
 */
function _boost_copy_js_files($js) {
  //extract js file name
  $js_files=explode('src="', $js);
  array_shift($js_files);
  for ($i = 0; $i < count($js_files); $i++) {
    $temp = array_shift(explode('"', $js_files[$i]));
    $temp = array_pop(explode('//', $temp));
    $temp = explode('.', $temp);
    array_pop($temp);
    $temp = explode(base_path(), implode('.', $temp));
    array_shift($temp);
    $js_files[$i] = implode(base_path(), $temp);
  }

  //copy files
  foreach ($js_files as $js_file) {
    if (file_exists($js_file . '.js')) {
      $src = $js_file . '.js';
      $dest = BOOST_PERM_FILE_PATH . '/' . $js_file . '.js' . BOOST_PERM_CHAR . BOOST_JS_EXTENSION;
      _boost_copy_file($src, $dest);
    }
    if (file_exists($js_file . '.js.gz')) {
      $src = $js_file . '.js.gz';
      $dest = BOOST_PERM_GZIP_FILE_PATH . '/' . $js_file . '.js' . BOOST_PERM_CHAR . BOOST_JS_EXTENSION . BOOST_GZIP_EXTENSION;
      _boost_copy_file($src, $dest);
    }
    elseif (BOOST_GZIP && file_exists($js_file . '.js')) {
      $src = $js_file . '.js';
      $dest = BOOST_PERM_GZIP_FILE_PATH . '/' . $js_file . '.js' . BOOST_PERM_CHAR . BOOST_JS_EXTENSION . BOOST_GZIP_EXTENSION;
      _boost_gz_copy_file($src, $dest);
    }
    if (file_exists($js_file . '.jsmin.js')) {
      $src = $js_file . '.jsmin.js';
      $dest = BOOST_PERM_FILE_PATH . '/' . $js_file . '.jsmin.js' . BOOST_PERM_CHAR . BOOST_JS_EXTENSION;
      _boost_copy_file($src, $dest);
    }
    if (file_exists($js_file . '.jsmin.js.gz')) {
      $src = $js_file . '.jsmin.js.gz';
      $dest = BOOST_PERM_GZIP_FILE_PATH . '/' . $js_file . '.jsmin.js' . BOOST_PERM_CHAR . BOOST_JS_EXTENSION . BOOST_GZIP_EXTENSION;
      _boost_copy_file($src, $dest);
    }
    elseif (BOOST_GZIP && file_exists($js_file . '.jsmin.js')) {
      $src = $js_file . '.jsmin.js';
      $dest = BOOST_PERM_GZIP_FILE_PATH . '/' . $js_file . '.jsmin.js' . BOOST_PERM_CHAR . BOOST_JS_EXTENSION . BOOST_GZIP_EXTENSION;
      _boost_gz_copy_file($src, $dest);
    }
  }
}

/**
 * Copy a file.
 *
 * @param $src
 *   Source File.
 * @param $dest
 *   Destination.
 */
function _boost_copy_file($src, $dest) {
  $destinations = _boost_copy_file_get_domains($dest);
  foreach ($destinations as $destination) {
    if (_boost_mkdir_p(dirname($destination))) {
      @copy($src, $destination);
      if (is_numeric(BOOST_PERMISSIONS_FILE)) {
        @chmod($tempfile, octdec(BOOST_PERMISSIONS_FILE));
      }
    }
  }
}

/**
 * Copy a file and gzip its contents
 *
 * @param $src
 *   Source File.
 * @param $dest
 *   Destination.
 */
function _boost_gz_copy_file($src, $dest) {
  $destinations = _boost_copy_file_get_domains($dest);
  foreach ($destinations as $destination) {
    if (_boost_mkdir_p(dirname($destination))) {
      @file_put_contents($destination, gzencode(file_get_contents($src), 9));
      if (is_numeric(BOOST_PERMISSIONS_FILE)) {
        @chmod($tempfile, octdec(BOOST_PERMISSIONS_FILE));
      }
    }
  }
}

/**
 * Get the various subdomains from parallel module.
 *
 * @param $dest
 *   Destination.
 */
function _boost_copy_file_get_domains($dest) {
  global $base_url;
  $parts = parse_url($base_url);
  $destinations = array();
  $destinations[] = $dest;
  $domains = array();
  $domains[] = str_replace('//', '', variable_get('parallel_domain_css', ''));
  $domains[] = str_replace('//', '', variable_get('parallel_domain_img', ''));
  $domains[] = str_replace('//', '', variable_get('parallel_domain_js', ''));
  $domains = array_unique(array_filter($domains));

  foreach ($domains as $domain) {
    $destinations[] = str_replace($parts['host'], $domain, $dest);
  }
  return $destinations;
}

/**
 * Gets page_callback & page_arguments from menu_router table
 *
 * Allows for any content type to have it's own cache expiration.
 */
function _boost_get_menu_router() {
  $original_map = arg(NULL, $_GET['q']);
  $parts = array_slice($original_map, 0, MENU_MAX_PARTS);
  list($ancestors, $placeholders) = menu_get_ancestors($parts);
  $router_item = db_fetch_array(db_query_range('SELECT page_callback, page_arguments FROM {menu_router} WHERE path IN ('. implode (',', $placeholders) .') ORDER BY fit DESC', $ancestors, 0, 1));
  $router_item['page_arguments'] = unserialize($router_item['page_arguments']);
  // Handle nodes
  if (arg(0) == 'node' && is_numeric(arg(1))) {
    $node = node_load(arg(1));
    $router_item['page_arguments'] = $node->type;
    $router_item['page_callback'] = 'node';
    $router_item['page_id'] = arg(1);

  }
  // Handle taxonomy
  elseif (arg(0) == 'taxonomy' && is_numeric(arg(2))) {
    $term = taxonomy_get_term(arg(2));
    $vocab = taxonomy_vocabulary_load($term->vid);
    $router_item['page_arguments'] = $vocab->name;
    $router_item['page_callback'] = 'taxonomy';
    $router_item['page_id'] = arg(2);
  }
  // Handle users
  if (arg(0) == 'user' && is_numeric(arg(1))) {
    $router_item['page_arguments'] = implode(', ', user_load(array('uid' => arg(1)))->roles);
    $router_item['page_callback'] = 'user';
    $router_item['page_id'] = arg(1);
  }
  // Try to handle everything else
  elseif (is_array($router_item['page_arguments'])) {
    foreach ($router_item['page_arguments'] as $string) {
      if (is_string($string)) {
        $router_item['page_arguments'] = $string;
        break;
      }
    }
  }
  // Set empty if page_arguments is an empty object.
  if (empty($router_item['page_arguments'])) {
    $router_item['page_arguments'] = '';
  }
  // Set to first object in array if page_arguments is still an array and cast it as an string.
  if (is_array($router_item['page_arguments'])) {
    $router_item['page_arguments'] = (string)$router_item['page_arguments'][0];
  }

  // Handle Views
  if ($router_item['page_callback'] == 'views_page') {
    $vid = db_fetch_array(db_query_range("SELECT vid FROM {views_view} WHERE name = '%s'", $router_item['page_arguments'], 0, 1));
    $router_item['page_id'] = $vid['vid'];
  }

  // Handle Panels
  if (strstr($router_item['page_callback'], 'page_execute')) {
    if (db_fetch_array(db_query("SHOW TABLES LIKE 'delegator_pages'"))) {
      $pid = db_fetch_array(db_query_range("SELECT pid FROM {delegator_pages} WHERE name = '%s'", $router_item['page_arguments'], 0, 1));
    }
    elseif (db_fetch_array(db_query("SHOW TABLES LIKE 'page_manager_pages'"))) {
      $pid = db_fetch_array(db_query_range("SELECT pid FROM {page_manager_pages} WHERE name = '%s'", $router_item['page_arguments'], 0, 1));
    }
    if ($pid) {
      $router_item['page_id'] = $pid['pid'];
    }
    else {
      $router_item['page_id'] = 0;
    }
  }

  return $router_item;
}

/**
 * Recursive version of mkdir(), compatible with PHP4.
 *
 * @param $pathname
 *   The top-level directory that will be recursively created.
 * @param $recursive
 *   Operate in a recursive manner.
 */
function _boost_mkdir_p($pathname, $recursive = TRUE) {
  $mode = is_numeric(BOOST_PERMISSIONS_DIR) ? octdec(BOOST_PERMISSIONS_DIR) : 0775;
  if (is_dir($pathname)) {
    return TRUE;
  }
  if ($recursive && !_boost_mkdir_p(dirname($pathname))) {
    return FALSE;
  }
  if ($result = @mkdir($pathname, $mode)) {
    @chmod($pathname, $mode);
  }
  return $result;
}

/**
 * Recursive version of rmdir(); use with extreme caution.
 *
 * @param $dirname
 *   the top-level directory that will be recursively removed
 * @param $flush
 *   optional nuke it all if true, otherwise kill only expired files
 * @param $first
 *   id first call to this function
 */
function _boost_rmdir_rf($dirname, $flush = TRUE, $first = TRUE) {
  $empty = TRUE; // Start with an optimistic mindset

  if ($first || (!$first && !file_exists($dirname . '/' . BOOST_ROOT_FILE))) {
    $files = glob($dirname . '/*', GLOB_NOSORT);
    if ($files) {
      foreach ($files as $file) {
        if (is_dir($file)) {
          if (!_boost_rmdir_rf($file, $flush, FALSE)) {
            $empty = FALSE;
          }
        }
        else if (is_file($file) || is_link($file)) {
          if (!$flush && !boost_db_is_expired($file)) {
            $empty = FALSE;
            continue;
          }
          @unlink($file);
        }
        else {
          $empty = FALSE; // it's something else, don't del to be safe.
        }
      }
    }
  }

  //do not delete the root dir
  if (file_exists($dirname . '/' . BOOST_ROOT_FILE)) {
    return ($empty);
  }

  // The reason for this elaborate safeguard is that Drupal will log even
  // warnings that should have been suppressed with the @ sign. Otherwise,
  // we'd just rely on the FALSE return value from rmdir().
  return ($empty && BOOST_FLUSH_DIR && @rmdir($dirname));
}

/**
 * Internal variable get; don't rely on cache table.
 *
 * @param $name
 *   variable name
 */
function _boost_variable_get($name) {
  return unserialize(db_result(db_query("SELECT value FROM {variable} WHERE name = '%s'", $name)));
}

/**
 * Internal variable set; don't rely on cache table.
 *
 * @param $name
 *   variable name
 * @param $value
 *   variable value
 */
function _boost_variable_set($name, $value) {
  db_query("UPDATE {variable} SET value = '%s' WHERE name = '%s'", serialize($value), $name);
}

/**
 * Generate iframe gzip cookie test html.
 */
function _boost_generate_gzip_test() {
  $filename = BOOST_ROOT_CACHE_DIR . '/' . BOOST_PERM_GZ_DIR . '/boost-gzip-cookie-test.html.gz';
  if (!file_exists($filename)) {
    $string = <<<ETO
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
  "http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>Gzip Test</title>
<script type="text/javascript">
var date = new Date();
var days = 14;
date.setTime(date.getTime() + (days * 24*60*60*1000));
expires = '; expires=' + date.toUTCString();
document.cookie = 'boost-gzip=true' + expires + '; path=/'
</script>
</head><body><h1>It works!</h1></body></html>
ETO;
    _boost_mkdir_p(dirname($filename));
    file_put_contents($filename, gzencode($string, 9));
  }

}

/**
 * Inject iframe gzip cookie test.
 */
function _boost_gzip_test_inject_iframe($data) {
 return str_replace('</body>', '<iframe src="/boost-gzip-cookie-test.html" style="width:0px; height:0px; border: 0px"></iframe>' . "\n" . '</body>', $data);
}

//////////////////////////////////////////////////////////////////////////////
// PHP 4.x compatibility

if (!function_exists('file_put_contents')) {
  function file_put_contents($filename, $data) {
    if ($fp = fopen($filename, 'wb')) {
      fwrite($fp, $data);
      fclose($fp);
      return filesize($filename);
    }
    return FALSE;
  }
}

//////////////////////////////////////////////////////////////////////////////
// Crawler Code

/**
 * The brains of the crawler.
 */
function boost_crawler_run() {
  // Set PHP INI Variables, try to prevent crawler from stalling.
  Global $base_url;
  ini_set('max_execution_time', 600);
  ini_set('output_buffering', 'off');
  $this_thread = (isset($_GET['thread']) && is_numeric($_GET['thread'])) ? $_GET['thread'] : NULL;
  $total_threads = (isset($_GET['total']) && is_numeric($_GET['total'])) ? $_GET['total'] : NULL;
  $self = BOOST_CRAWLER_SELF;

  if ($_GET['q'] == 'boost-crawler') {
    // if not called via cron, require key to be present in url
    if ($_GET['key'] != variable_get('boost_crawler_key', FALSE)) {
      drupal_access_denied();
      exit;
    }
    // Test for access on status page
    if ($_GET['test']) {
      echo '<h1>OK</h1>';
      exit;
    }

    // Return html so connection closes
    boost_async_opp('async');

    // Wait 10 seconds if first run and try again (let cron finish).
    if (variable_get('cron_semaphore', FALSE) == TRUE) {
      if (BOOST_VERBOSE >= 5) {
        watchdog('boost', 'Crawler Sleep');
      }
      sleep(10);
      boost_async_call_crawler($self, $this_thread, $total_threads);
      exit;
    }
    // Start to do crawler stuff
    else {
      if (boost_crawler_seed_tables()) {
        //Spin Up Threads
        if (!_boost_variable_get('boost_crawler_threads_primed')) {
          variable_set('boost_crawler_threads_primed', TRUE);
          $total = boost_crawler_total_count() - BOOST_CRAWLER_BATCH_SIZE;
          $threads = BOOST_CRAWLER_THREADS;
          if ($total/BOOST_CRAWLER_BATCH_SIZE < BOOST_CRAWLER_THREADS) {
            $threads = floor($total/BOOST_CRAWLER_BATCH_SIZE);
          }
          variable_set('boost_crawler_number_of_threads', (int)$threads);
          while ($threads > 0) {
            boost_async_call_crawler($self, $threads, variable_get('boost_crawler_number_of_threads', $threads));
            $threads--;
          }
          if (BOOST_VERBOSE >= 5) {
            watchdog('boost', 'All @num threads started', array('@num' => variable_get('boost_crawler_number_of_threads', $threads)));
          }
          variable_set('boost_crawler_start_time', BOOST_TIME);
          exit;
        }

        // Stop button code
        if (_boost_variable_get('boost_crawler_stopped')) {
          // Wait 0 to 0.1 seconds before grabbing number of threads.
          usleep(mt_rand(0, 100000));
          db_lock_table('variable');
          $threads = _boost_variable_get('boost_crawler_number_of_threads');
          _boost_variable_set('boost_crawler_number_of_threads', $threads-1);
          db_unlock_tables();
          if (BOOST_VERBOSE >= 5) {
            watchdog('boost', 'Crawler - Thread %num of %total Stopped.', array('%num' => $this_thread, '%total' => $total_threads));
          }
          exit;
        }

        // Wait 0 to 0.1 seconds before grabbing DB position counter.
        usleep(mt_rand(0, 100000));
        db_lock_table('variable');
        $from = _boost_variable_get('boost_crawler_position');
        _boost_variable_set('boost_crawler_position', $from + BOOST_CRAWLER_BATCH_SIZE);
        db_unlock_tables();

        $results = db_query_range("SELECT url FROM {boost_crawler} ORDER BY id ASC", $from, BOOST_CRAWLER_BATCH_SIZE);
        $url = db_result($results);
        if ($url) {
          drupal_http_request($url);
          if (BOOST_CRAWLER_THROTTLE) {
            usleep(BOOST_CRAWLER_THROTTLE);
          }
          set_time_limit(0);
        }
        else {
          // Wait 0 to 0.1 seconds before grabbing number of threads.
          usleep(mt_rand(0, 100000));
          db_lock_table('variable');
          $threads = _boost_variable_get('boost_crawler_number_of_threads');
          _boost_variable_set('boost_crawler_number_of_threads', $threads-1);
          db_unlock_tables();
          if (BOOST_VERBOSE >= 5) {
            watchdog('boost', 'Crawler - Thread %num of %total Done.', array('%num' => $this_thread, '%total' => $total_threads));
          }
          // Re init crawler if it missed some, try 5 times
          if (   _boost_variable_get('boost_crawler_number_of_threads') == 0
              && _boost_variable_get('boost_crawler_number_of_tries') < 5
              && boost_crawler_verify()
              ) {
            _boost_variable_set('boost_crawler_number_of_threads', 1);
            if (BOOST_VERBOSE >= 5) {
              watchdog('boost', 'Crawler - Restarting with 1 thread, to try & get the stubborn urls cached.');
            }
            boost_async_call_crawler($self, 1, 1);
            exit;
          }

          return TRUE;
        }
        while ($url = db_result($results)) {
          drupal_http_request($url);
          if (BOOST_CRAWLER_THROTTLE) {
            usleep(BOOST_CRAWLER_THROTTLE);
          }
          set_time_limit(0);
        }
        // Crawler for this round done, call self and exit
        boost_async_call_crawler($self, $this_thread, $total_threads);
        exit;
      }
      else {
        // URL's added to table, call self and exit
        //watchdog('boost', 'Loading URL\'s');
        boost_async_call_crawler($self, $this_thread, $total_threads);
        exit;
      }
    }
  }
  elseif (variable_get('boost_crawler_number_of_threads', 0) > 0) {
    if (BOOST_VERBOSE >= 3) {
      watchdog('boost', 'Crawler already running');
     }
    drupal_set_message(t('Boost: Crawler is already running. Attempt to start crawler failed.'), 'warning');
  }
  elseif (variable_get('cron_semaphore', FALSE) == TRUE) {
    // This function called from cron; reset & call self.
    if (BOOST_VERBOSE >= 5) {
      watchdog('boost', 'Crawler Start ' . $self);
    }
    db_query('TRUNCATE {boost_crawler}');
    variable_set('boost_crawler_position', 0);
    variable_set('boost_crawler_loaded_count' . BOOST_FILE_EXTENSION, 0);
    variable_set('boost_crawler_loaded_count' . BOOST_XML_EXTENSION, 0);
    variable_set('boost_crawler_loaded_count' . BOOST_JSON_EXTENSION, 0);
    variable_set('boost_crawler_loaded_count_alias', 0);
    variable_set('boost_crawler_threads_primed', FALSE);
    variable_set('boost_crawler_number_of_tries', 0);
    variable_set('boost_crawler_stopped', FALSE);
    boost_async_call_crawler($self, $this_thread, $total_threads);
    return TRUE;
  }
}

/**
 * Output text & set php in async mode.
 */
function boost_async_opp($output) {
  // Prime php for background operations
  ob_end_clean();
  header("Connection: close");
  ignore_user_abort();

  // Output text
  ob_start();
  header("Content-type: text/html");
  header("Expires: Wed, 11 Nov 1998 11:11:11 GMT");
  header("Cache-Control: no-cache");
  header("Cache-Control: must-revalidate");
  header("Content-Length: " . (strlen($output)-1));
  header("Connection: close");
  print($output);
  ob_end_flush();
  flush();
  // wait for 1 second
  sleep(1);

  // text returned and connection closed.
  // Do background processing. Time taken after should not effect page load times.
}

/**
 * Call a URL with a timeout of 3 seconds.
 *
 * @param $self
 *  URL to restart the loop.
 */
function boost_async_call_crawler($self, $this_thread = NULL, $total_threads = NULL) {
  $self .= isset($this_thread) ? '&thread=' . $this_thread : '';
  $self .= isset($total_threads) ? '&total=' . $total_threads : '';

  $timeout = ini_get('default_socket_timeout');
  ini_set('default_socket_timeout', 3);
  @file_get_contents($self);
  ini_set('default_socket_timeout', $timeout);
}

/**
 * Add URL's to the boost_crawler table.
 *
 * @param $push_setting
 *  Default crawler setting for the content type
 * @param $extension
 *  File extension, controls the content type DB lookup
 */
function boost_crawler_add_to_table($push_setting, $extension) {
  // Insert batch of URL's into boost_crawler table
  $count = 10000;
  $total = boost_crawler_count($push_setting, $extension);
  $loaded = variable_get('boost_crawler_loaded_count' . $extension, 0);
  if ($total > $loaded) {
    if ($push_setting) {
      db_query_range("INSERT INTO {boost_crawler} (url) SELECT url FROM {boost_cache} WHERE push != 0 AND extension = '%s' AND expire = 0", $extension, $loaded, $count);
    }
    else {
      db_query_range("INSERT INTO {boost_crawler} (url) SELECT url FROM {boost_cache} WHERE push = 1 AND extension = '%s' AND expire = 0", $extension, $loaded, $count);
    }
    variable_set('boost_crawler_loaded_count' . $extension, $loaded + $count);
    return FALSE;
  }
  else {
    return TRUE;
  }
}

/**
 * Count the number of URL's in the boost_cache table.
 *
 * @param $push_setting
 *  Default crawler setting for the content type
 * @param $extension
 *  File extension, controls the content type DB lookup
 */
function boost_crawler_count($push_setting, $extension) {
  if ($push_setting) {
    return db_result(db_query("SELECT COUNT(*) FROM {boost_cache} WHERE push != 0 AND extension = '%s' AND expire = 0", $extension));
  }
  else {
    return db_result(db_query("SELECT COUNT(*) FROM {boost_cache} WHERE push = 1 AND extension = '%s' AND expire = 0", $extension));
  }
}

/**
 * Logic to get boost_crawler table ready.
 */
function boost_crawler_seed_tables() {
  if (   boost_crawler_add_to_table(BOOST_PUSH_HTML, BOOST_FILE_EXTENSION)
      && boost_crawler_add_to_table(BOOST_PUSH_XML, BOOST_XML_EXTENSION)
      && boost_crawler_add_to_table(BOOST_PUSH_JSON, BOOST_JSON_EXTENSION)
      && boost_crawler_add_alias_to_table()
      ) {
    // All URL's added to boost_crawler table; start hitting URL's
    return TRUE;
  }
  else {
    return FALSE;
  }
}

/**
 * Get URLs from url alias table
 */
function boost_crawler_add_alias_to_table() {
  // Insert batch of html URL's into boost_crawler table
  global $base_url;
  if (!variable_get('boost_crawl_url_alias', FALSE)) {
    return TRUE;
  }
  $count = 1000;
  $total = db_query("SELECT COUNT(*) FROM {url_alias}");
  $loaded = variable_get('boost_crawler_loaded_count_alias', 0);
  if ($total > $loaded) {
    $list = db_query_range("SELECT dst FROM {url_alias}", $loaded, $count);
    while ($url = db_result($list)) {
      @db_query("INSERT INTO {boost_crawler} (url) VALUES ('%s')", $base_url . '/' . $url);
    }
    variable_set('boost_crawler_loaded_count_alias', $loaded + $count);
    return FALSE;
  }
  else {
    return TRUE;
  }
}

/**
 * Get count of boost_crawler table.
 */
function boost_crawler_total_count() {
  return db_result(db_query("SELECT COUNT(*) FROM {boost_crawler}"));
}

/**
 * Reload any url's that did not get cached.
 */
function boost_crawler_verify() {
  $list = db_query("SELECT boost_crawler.url FROM {boost_cache} INNER JOIN {boost_crawler} ON boost_cache.url=boost_crawler.url WHERE boost_cache.expire = 0");
  db_query('TRUNCATE {boost_crawler}');
  variable_set('boost_crawler_position', 0);
  $recrawl = FALSE;
  while ($url = db_result($list)) {
    db_query("INSERT INTO {boost_crawler} (url) VALUES ('%s')", $url);
    $recrawl = TRUE;
  }
  return $recrawl;
}